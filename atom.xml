<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bad2cat</title>
  
  
  <link href="https://xinwazi.com/atom.xml" rel="self"/>
  
  <link href="https://xinwazi.com/"/>
  <updated>2022-06-17T07:48:55.125Z</updated>
  <id>https://xinwazi.com/</id>
  
  <author>
    <name>Adx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-74f5876a802b/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-74f5876a802b/</id>
    <published>2022-06-17T07:40:52.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>代理就是替别人完成某个任务，代理模式就是代替客户端去完成客户端需要完成的请求；代理模式和装饰器模式虽然在结构上比较相似，但是它们表达的意义和产生的结果还是有一定的差别的</p><span id="more"></span><p>装饰器模式更像是流水线上的产品，一开始的时候只有一个雏形，经过一些列的装饰器装饰之后就会形成最终需要的产品，也就是说，它最终的结果有可能与一开始的不同</p><p>代理模式是帮助客户端去完成客户端不想或者是不能实现的操作，比如：使用<code>http</code>代理翻墙，如果你不使用代理，那么访问像<code>http://www.google.com</code>这样的网站时就会被墙，当你使用<code>http</code>代理时就可以绕过这个墙，将请求发出去，然后获取到响应（虽然 <code>http</code>代理也很容易被墙）</p><p>当然，还有一些其他的应用，比如：要实现一个图片下载的服务，如果客户端每次都要从服务器下载，那既浪费时间又会增加服务器的压力，如果能够在客户端有一个代理，在图片第一次下载之后就缓存下来，之后就从这个缓存中获取就会解决这些问题，图片如果不在缓存的话，代理帮你去下载下来返回给客户端，然后添加到缓存中</p><h5 id="代理的类图结构"><a href="#代理的类图结构" class="headerlink" title="代理的类图结构"></a>代理的类图结构</h5><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-74f5876a802b/proxy.png" alt="proxy"></p><p>客户端将请求发送到代理，代理收到请求之后检查客户端的权限（如果需要的话），然后将请求发送<code>Service</code>，<code>Service</code>收到请求，返回给代理，再由代理返回给客户端</p><p>下面是<code>HTTP</code>代理的一个结构图</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-74f5876a802b/http%E4%BB%A3%E7%90%86.png" alt="proxy"></p><p>用户访问<code>https://www.google.com</code>，浏览器收到用户请求之后，将请求发送到代理服务器（因为代理服务器不在防火墙的黑名单里，所以可以正常接收到请求），代理服务器收到请求之后将请求转发到<code>google</code>服务器（代理服务器在墙外，所以不受限制），<code>google</code>服务器收到请求后，将结果返回给代理服务器，代理服务器再将请求返回给浏览器；这样就能够实现翻墙了</p><h5 id="代理模式的Go代码实现"><a href="#代理模式的Go代码实现" class="headerlink" title="代理模式的Go代码实现"></a>代理模式的<code>Go</code>代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path1 := <span class="string">&quot;/api/v1/create/user&quot;</span></span><br><span class="line">path2 := <span class="string">&quot;/api/v1/update/user&quot;</span></span><br><span class="line">path3 := <span class="string">&quot;/api/v1/delete/user&quot;</span></span><br><span class="line"></span><br><span class="line">app := NewApplication()</span><br><span class="line">p := NewProxy(app,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">result1 := p.handleRequest(path1)</span><br><span class="line">fmt.Println(result1)</span><br><span class="line">result2 := p.handleRequest(path2)</span><br><span class="line">fmt.Println(result2)</span><br><span class="line">result3 := p.handleRequest(path3)</span><br><span class="line">fmt.Println(result3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">interface</span> &#123;</span><br><span class="line">handleRequest(<span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Application is real server</span></span><br><span class="line"><span class="keyword">type</span> Application <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Application)</span></span> handleRequest(s <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;/api/v1/create/user&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;create success&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;/api/v1/update/user&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;update success&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;path not found&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApplication</span><span class="params">()</span></span> *Application &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Application&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy</span></span><br><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line">app                 *Application</span><br><span class="line">allowedRequestTimes <span class="type">int</span></span><br><span class="line">rateLimiter         <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Proxy)</span></span> handleRequest(s <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">allowed := p.checkRequestLimiter(s)</span><br><span class="line"><span class="keyword">if</span> allowed &#123;</span><br><span class="line"><span class="keyword">return</span> p.app.handleRequest(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;over request time&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Proxy)</span></span> checkRequestLimiter(url <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t, ok := p.rateLimiter[url]; ok &#123;</span><br><span class="line"><span class="keyword">if</span> t &gt; p.allowedRequestTimes &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">p.rateLimiter[url] = t + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.rateLimiter[url] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxy</span><span class="params">(app *Application, t <span class="type">int</span>)</span></span> *Proxy &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Proxy&#123;</span><br><span class="line">app:                 app,</span><br><span class="line">allowedRequestTimes: t,</span><br><span class="line">rateLimiter:         <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;代理就是替别人完成某个任务，代理模式就是代替客户端去完成客户端需要完成的请求；代理模式和装饰器模式虽然在结构上比较相似，但是它们表达的意义和产生的结果还是有一定的差别的&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="代理模式" scheme="https://xinwazi.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-外观模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-1fc904650307/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-1fc904650307/</id>
    <published>2022-05-23T01:12:13.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>外观模式是一种结构型设计模式，就是为程序、框架和复杂的类提供简单的接口，方便客户端的使用</p><span id="more"></span><h5 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h5><p>记得小的时候看的都是那种黑白电视，如果需要更换频道，就要去找到频道模块，然后更换；如果要调整声音大小，那还得跑到电视机前面，找到声音模块调节声音；如果你又觉得电视太暗，你还得跑到电视机跟前，找到明亮度按钮来调整；也就是说，对电视的每个操作都得到电视机上找到对应的模块进行操作，这着实麻烦</p><p>后面厂家通过红外技术将电视上这些相关的功能全部封装到了遥控器当中，这样只需要操作遥控器就好了，就不再需要每次都跑到电视机前操作了了</p><p>这种应用就是今天要介绍的外观模式，封装多个子系统，只为客户端提供统一的接口，客户端只需要跟这个封装后的对象交互就可以了，不需要关注每个子系统具体的实现细节了</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>外观模式简化了客户端和复杂框架之间的交互，封装了客户端所需的功能，隐藏了实现细节，简化了客户端的使用</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-1fc904650307/facade.png" alt="facade"></p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := NewRemoter()</span><br><span class="line">r.ChangeChannerl()</span><br><span class="line">r.AddLight(<span class="number">3</span>)</span><br><span class="line">r.ReduceLight(<span class="number">2</span>)</span><br><span class="line">r.AddAudio(<span class="number">2</span>)</span><br><span class="line">r.RecudeAudio(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Remoter <span class="keyword">struct</span> &#123;</span><br><span class="line">c *VideoChannel</span><br><span class="line">a *VideoAudio</span><br><span class="line">l *VideoLight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRemoter</span><span class="params">()</span></span> *Remoter &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Remoter&#123;</span><br><span class="line">c: &amp;VideoChannel&#123;&#125;,</span><br><span class="line">a: &amp;VideoAudio&#123;&#125;,</span><br><span class="line">l: &amp;VideoLight&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Remoter)</span></span> ChangeChannerl() &#123;</span><br><span class="line">r.c.changeChannel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Remoter)</span></span> AddAudio(n <span class="type">int</span>) &#123;</span><br><span class="line">r.a.AddAudio(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Remoter)</span></span> RecudeAudio(n <span class="type">int</span>) &#123;</span><br><span class="line">r.a.ReduceAudio(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Remoter)</span></span> AddLight(n <span class="type">int</span>) &#123;</span><br><span class="line">r.l.AddLight(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Remoter)</span></span> ReduceLight(n <span class="type">int</span>) &#123;</span><br><span class="line">r.l.Reduce(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VideoChannel <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VideoChannel)</span></span> changeChannel() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;change channel&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VideoAudio <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VideoAudio)</span></span> AddAudio(n <span class="type">int</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;add %d audio\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VideoAudio)</span></span> ReduceAudio(n <span class="type">int</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;reduce audio %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VideoLight <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VideoLight)</span></span> AddLight(n <span class="type">int</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;add light %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VideoLight)</span></span> Reduce(n <span class="type">int</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;reduce light %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>避免了客户端和子系统之间的紧耦合，增加了代码的灵活性</p><p>客户端不需要了解每个子系统的所有功能，只需要调用自己的需要的功能就好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;外观模式是一种结构型设计模式，就是为程序、框架和复杂的类提供简单的接口，方便客户端的使用&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="外观模式" scheme="https://xinwazi.com/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="结构型模式" scheme="https://xinwazi.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-组合模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-b64439743afc/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-b64439743afc/</id>
    <published>2022-05-09T01:12:13.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式，又称为部分-整体模式，是一种结构型设计模式，可以使用它将相似对象组合成树状结构，并且能像使用独立对象一样使用它们</p><span id="more"></span><h4 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h4><p>有两类对象：盒子和商品；一个盒子中有多个商品和更小的盒子，而在这些小的盒子中又有其他的商品和一些更小的盒子，而这些更小的盒子中也有商品和其他更小的盒子，依次类推</p><p>现在需要在这些类的基础上开发一个订单系统，在订单中可以包含无包装的商品，也可以包含包装其他商品的盒子，以及其他的盒子；那此时如何计算每张订单的总价呢？</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-b64439743afc/q.png" alt="q"></p><p>当然，在现实的生活中，可以一个个的打开所有的盒子，然后将所有盒子中的商品价格加起来就好了</p><p>但是，在程序中不能简单的使用循环来完成这种工作；因为，首先你必须知道所有的盒子和商品的类别；其次，你要知道所有的嵌套层数，以及每个盒子的包装细节；这对于程序来说一层层的拆分会变得的非常的复杂，甚至基本不可以</p><p>那现在如何才能通过程序解决这个问题呢？答案就是使用组合模式</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>组合模式建议通过一个通用的接口与商品和盒子进行交互，并且在这个接口中声明一个计算总价的方法；现在的重点就是放到了如何实现这个计算总价的方法了</p><p>对于一个盒子，该方法遍历这个盒子中所有的对象，询问每个对象的价格，然后返回这个盒子的总价；对于一个商品，则直接返回这个商品的价格</p><p>如果在这个盒子中还存在其他更小的盒子，遍历这个盒子的所有对象的价格，依次类推，直到计算出所有内部组成部分的价格为止；当然，你也可以在计算每个盒子的价格的时候附加上这个盒子的包装价格作为和盒子的费用</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-b64439743afc/a.png" alt="a"></p><p>组合模式的最大的优点就是无需了解这个树状结构中对象的具体类型；你也不需要知道对象是商品还是盒子；只需要调用通用的接口中的方法，以相同的方式对其进行处理即可；当你调用该方法后，对象就会沿着这个树结构传递下去</p><h5 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h5><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-b64439743afc/UML.png" alt="UML"></p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">smallBox := NewGoodsBox()</span><br><span class="line">pen := NewPen(<span class="number">10</span>)</span><br><span class="line">book := NewBook(<span class="number">12</span>)</span><br><span class="line">smallBox.Add(pen)</span><br><span class="line">smallBox.Add(book)</span><br><span class="line"></span><br><span class="line">bigBox := NewGoodsBox()</span><br><span class="line">p1 := NewPen(<span class="number">20</span>)</span><br><span class="line">p2 := NewPen(<span class="number">10</span>)</span><br><span class="line">b1 := NewBook(<span class="number">1</span>)</span><br><span class="line">bigBox.Add(p1)</span><br><span class="line">bigBox.Add(p2)</span><br><span class="line">bigBox.Add(b1)</span><br><span class="line">bigBox.Add(smallBox)</span><br><span class="line"></span><br><span class="line">total := bigBox.Compute()</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">Compute() <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GoodsBox <span class="keyword">struct</span> &#123;</span><br><span class="line">c []Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGoodsBox</span><span class="params">()</span></span> *GoodsBox &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;GoodsBox&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoodsBox)</span></span> Add(c Component) &#123;</span><br><span class="line"><span class="keyword">if</span> g.c == <span class="literal">nil</span> &#123;</span><br><span class="line">g.c = <span class="built_in">make</span>([]Component, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">g.c = <span class="built_in">append</span>(g.c, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoodsBox)</span></span> Compute() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> g.c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> g.c &#123;</span><br><span class="line">total = total + c.Compute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pen <span class="keyword">struct</span> &#123;</span><br><span class="line">price <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPen</span><span class="params">(price <span class="type">int64</span>)</span></span> *Pen &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Pen&#123;price: price&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pen)</span></span> Compute() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">price <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBook</span><span class="params">(price <span class="type">int64</span>)</span></span> *Book &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Book&#123;price: price&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Book)</span></span> Compute() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.price</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>组合模式可适用于整体和部分可以统一处理的场景中；比如，学校要统计学生的男女比例，那首先就需要先拿到每个班级的男女生人数，接下来就是统计每个专业的男女人数，每个学院的男女人数，最后获取到整个学校的男女人数，这样就可以获取到整个学校的男女比例了</p><p>同样的，不同的对象之间是相互独立的，比如上面的场景中，每个班级也可以计算各个班级的男女比例，每个学院也可以计算各个学院的男女比例，相互之间不会有影响</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>不同类型的对象之间相互独立，一个节点类型的的变化不会影响其他的节点类型</p><p>程序的扩展性增强，新增新的节点类型，不会造成对原有结构造成影响</p><p>使得客户端对单个对象和组合对象的使用具有一致性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;组合模式，又称为部分-整体模式，是一种结构型设计模式，可以使用它将相似对象组合成树状结构，并且能像使用独立对象一样使用它们&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="结构型模式" scheme="https://xinwazi.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="组合模式" scheme="https://xinwazi.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/</id>
    <published>2022-05-09T01:12:13.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>装饰模式是一种结构型设计模式，是在运行时动态的给现有对象增加一些功能，但同时又不会改变原对象的代码结构</p><p>装饰器本质上就是创建一个装饰类，包装了原有类，并且保持装饰类和原有类有相同的方法签名，然后在原有类的方法上增加一些其他的功能</p><p>那装饰器主要是用来解决什么问题呢</p><span id="more"></span><h5 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h5><p>通常，当你想要扩展一个类的功能时，首先想到的方法就是使用继承，这样子类不但有了父类的功能，还能对其添加一些新的功能</p><p>但使用继承的问题就是，继承产生了一个新的静态类型，无法在运行时修改其行为，只能通过子类来代替父类；并且随着功能的不断增加，会出现各种各样不同的子类，不断增加的子类会导致程序变的越来越复杂</p><p>比如：公司有一个异常通知机制（Notifier），一开始的时候只会通过邮件（E-Mail）进行通知</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/notifier.png" alt="notifier"></p><p>但是，为了能使用户及时响应异常，又增加了短信（Text-Message）通知机制，微信（Wechat）等通知机制；所以，为了满足这种需求就让其他的通知类继承<code>Notifier</code>，然后各个子类再实现自己的通知机制就好了</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/notifier_impl.png" alt="notifier_impl"></p><p>后来发现，多种不同的通知机制能更加快速的通知到用户，所以现在要在出现异常时用多种通知机制通知用户，比如：同时支持短信和微信，或者同时支持邮件和短信等等</p><p>但如果还是使用继承的方式，子类的个数就完全不可控了；这不仅增加了通知代码库的复杂度，同时也会使得客户端代码变的异常的复杂</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/notifer_explode.png" alt="notifer_explode"></p><p>那现在如何解决这种子类不断膨胀的问题呢？答案就是使用装饰模式</p><h5 id="如何解决这个问题"><a href="#如何解决这个问题" class="headerlink" title="如何解决这个问题"></a>如何解决这个问题</h5><p>封装器是装饰模式的别称，封装器就是在一个对象中封装另一个类的对象，并且与目标对象有相同的方法签名；当接收到客户端的请求的时候，封装器会委派目标对象完成指定的功能，然后再在该方法之前或者之后增加一些自己的代码逻辑，最终有可能改变运行结果</p><p>那什么时候封装器可以被称之为真正的装饰器呢？因为封装器与原对象实现了相同的接口，所以对于客户端而言，这些对象是完全一样的</p><p>封装器中引用的成员变量可以是遵循相同接口的任意对象，这使得你可以将一个对象放入多个封装器内，并且在该对象上添加这个封装器的组合功能，这就使得封装器变成了一个具有装饰功能的装饰器了</p><p>这感觉就像是流水线的工程一样，每到一个节点就会在原有的基础上增加一些新的功能，最终完成整个产品的装配</p><p>在消息通知中，我们可以将邮件通知放在基类的通知器当中，而将其他的通知方式放到装饰器当中，并且是他们都是实现相同的接口</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/decator.png" alt="decator"></p><p>在客户端代码中将基础的通知器放入一系列所需要的装饰器当中，形成一个栈结构</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/stack.png" alt="stack"></p><p>因为所有的装饰器都实现了相同的接口，所以客户端只需要和最后一个入栈的对象交互就可以了，并不需要关心是和纯粹的通知器对象交互还是和装饰器对象交互</p><p>我们可以使用相同方法来完成其他行为 （例如设置消息格式或者创建接收人列表）。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象</p><h5 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a><code>UML</code> 类图</h5><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/UML.png" alt="UML"></p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">e := &amp;ExceptionNotifier&#123;&#125;</span><br><span class="line">s := NewWechatNotifer(e)</span><br><span class="line">s = NewTextMessageNotifier(s)</span><br><span class="line"></span><br><span class="line">s.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExceptionNotifier <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ExceptionNotifier)</span></span> Notify() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;exception notify&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WechatNotifier <span class="keyword">struct</span> &#123;</span><br><span class="line">notifier Notifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWechatNotifer</span><span class="params">(notifier Notifier)</span></span> Notifier &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;WechatNotifier&#123;notifier:notifier&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WechatNotifier)</span></span> Notify() &#123;</span><br><span class="line">w.notifier.Notify()</span><br><span class="line">fmt.Println(<span class="string">&quot;Notify with wechat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TextMessageNotifier <span class="keyword">struct</span> &#123;</span><br><span class="line">notifier Notifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTextMessageNotifier</span><span class="params">(notifier Notifier)</span></span> Notifier &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TextMessageNotifier&#123;notifier:notifier&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TextMessageNotifier)</span></span> Notify() &#123;</span><br><span class="line">t.notifier.Notify()</span><br><span class="line">fmt.Println(<span class="string">&quot;Notify with textMsg&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>如果不想更改现有的对象，并且希望在运行的时候为现有对象增加新的功能，就可以使用装饰器模式；它可以对原有的对象在运行时增加各种所需要的功能，并且不需要你更改原对象的代码结构</p><p>如果你发现使用继承的方式扩展对象的功能会使得代码变的的很复杂，那么就可以使用装饰器模式，通过组合的方式，使得代码更加的灵活</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>装饰模式的一些优点：</p><ul><li>可以更加灵活的扩展原对象的功能</li><li>可以将大功能拆分成各种装饰器，增加代码的灵活性和复用性</li></ul><p>装饰模式的一些缺点：</p><ul><li>在封装器栈中删除特定的封装器比较困难</li><li>各层代码的初始化配置会比较的麻烦</li></ul><p>参考链接：<a href="https://refactoringguru.cn/design-patterns/decorator">https://refactoringguru.cn/design-patterns/decorator</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;装饰模式是一种结构型设计模式，是在运行时动态的给现有对象增加一些功能，但同时又不会改变原对象的代码结构&lt;/p&gt;
&lt;p&gt;装饰器本质上就是创建一个装饰类，包装了原有类，并且保持装饰类和原有类有相同的方法签名，然后在原有类的方法上增加一些其他的功能&lt;/p&gt;
&lt;p&gt;那装饰器主要是用来解决什么问题呢&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="结构型模式" scheme="https://xinwazi.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="装饰模式" scheme="https://xinwazi.com/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Go依赖管理</title>
    <link href="https://xinwazi.com/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-a6e27b527321/"/>
    <id>https://xinwazi.com/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-a6e27b527321/</id>
    <published>2022-05-05T09:56:40.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>go</code>中有两个非常重要的环境变量：</p><ul><li><code>GOROOT</code>： <code>golang</code>的安装路径，Linux 下默认会安装在<code>/usr/local/go</code>之下</li><li><code>GOPATH</code>：存放<code>SDK</code>以外的第三方类库；收藏的可复用的代码，包含三个子目录： – src : 存放项目源码文件 – pkg : 编译后的包文件 – bin ：编译后生成的可执行文件</li></ul><span id="more"></span><h4 id="Go-Module"><a href="#Go-Module" class="headerlink" title="Go Module"></a>Go Module</h4><p>从 <code>Go1.11</code>版本开始，引入了<code>Go Module</code>功能，在程序中只有一个<code>go.mod</code>文件，存放依赖列表，而依赖的具体的包默认会下载到<code>GOPATH/pkg/mod</code>目录下面</p><p>在运行 <code>go build</code>时，优先引用<code>go.mod</code>文件中的依赖，所以<code>Vendor</code>目录逐渐的被替代了，消失在了大部分的项目当中</p><h5 id="go-mod的使用"><a href="#go-mod的使用" class="headerlink" title="go mod的使用"></a><code>go mod</code>的使用</h5><p>在<code>go 1.13</code>以后，<code>go mod</code>就是默认的依赖管理工具，在项目中使用如下的方式创建<code>go.mod</code>文件夹管理依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod int</span><br></pre></td></tr></table></figure><p>这样整个项目就可以使用<code>go mod</code>来进行管理了</p><p>下面是 <code>go mod </code>的一些常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go mod download 下载模块到本地缓存，缓存路径是 $GOPATH/pkg/mod/cache</span><br><span class="line">go mod edit 是提供了命令版编辑 go.mod 的功能，例如 go mod edit -fmt go.mod 会格式化 go.mod</span><br><span class="line">go mod graph 把模块之间的依赖图显示出来</span><br><span class="line">go mod init 初始化模块（例如把原本dep管理的依赖关系转换过来）</span><br><span class="line">go mod tidy 增加缺失的包，移除没用的包</span><br><span class="line">go mod vendor 把依赖拷贝到 vendor/ 目录下</span><br><span class="line">go mod verify 确认依赖关系</span><br><span class="line">go mod why 解释为什么需要包和模块</span><br></pre></td></tr></table></figure><p><code>go mod</code>中存在的一些问题：</p><ol><li><p>依赖包的地址失效或者下载失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时可以使用 go.mod 文件中的 replace 来替换这个包</span><br></pre></td></tr></table></figure></li><li><p>之前的项目如何使用<code>go mod</code>管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先把项目移出$GOPATH/src目录，然后运行 go mod init module_name，最后执行 go build 即可</span><br></pre></td></tr></table></figure></li></ol><h4 id="Go-Vendor"><a href="#Go-Vendor" class="headerlink" title="Go Vendor"></a>Go Vendor</h4><p><code>Vendor</code> 目录是<code>Golang1.5</code>版本引入的，为项目提供了一种离线保存第三方依赖的方法；使用<code>vendor</code>的项目，搜索依赖的顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前包下的 vendor 目录</span><br><span class="line">向上级目录查找，直到找到 src 下的 vendor 目录</span><br><span class="line">在 GOROOT 目录下查找</span><br><span class="line">在 GOPATH 下面查找依赖包</span><br></pre></td></tr></table></figure><h6 id="项目中使用go-vendor"><a href="#项目中使用go-vendor" class="headerlink" title="项目中使用go vendor"></a>项目中使用<code>go vendor</code></h6><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/kardianos/govendor</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd xxx</span><br><span class="line">govendor init</span><br></pre></td></tr></table></figure><p>初始化完成后，项目目录中会生成一个vendor文件夹，包含一个vendor.json文件，json文件中包含了项目所依赖的所有包信息</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;comment&quot;: &quot;&quot;,</span><br><span class="line"> &quot;ignore&quot;: &quot;test&quot;,</span><br><span class="line"> &quot;package&quot;: [],</span><br><span class="line"> &quot;rootPath&quot;: &quot;govendor-test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="govendor常用命令"><a href="#govendor常用命令" class="headerlink" title="govendor常用命令"></a><code>govendor</code>常用命令</h6><ul><li><p>将已被引用且在 $GOPATH 下的所有包复制到 vendor 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor add +external</span><br></pre></td></tr></table></figure></li><li><p>仅从 $GOPATH 中复制指定包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor add gopkg.in/yaml.v2</span><br></pre></td></tr></table></figure></li><li><p>列出一个包被哪些包引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor list -v fmt</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库添加或更新某个包(<strong>不会</strong>在 <code>$GOPATH</code> 也存一份)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch golang.org/x/net/context</span><br></pre></td></tr></table></figure></li><li><p>安装指定版本的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</span><br><span class="line">govendor fetch golang.org/x/net/context@v1   # Get latest v1.*.* tag or branch.</span><br><span class="line">govendor fetch golang.org/x/net/context@=v1  # Get the tag or branch named &quot;v1&quot;.</span><br></pre></td></tr></table></figure></li><li><p>只格式化项目自身代码(<code>vendor</code> 目录下的不变动)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor fmt +local</span><br></pre></td></tr></table></figure></li><li><p>拉取所有依赖的包到 <code>vendor</code> 目录(包括 <code>$GOPATH</code> 存在或不存在的包)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch +out</span><br></pre></td></tr></table></figure></li><li><p>包已在 <code>vendor</code> 目录，但想从 <code>$GOPATH</code> 更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor update +vendor</span><br></pre></td></tr></table></figure></li></ul><p>各子命令详细用法可通过 <code>govendor COMMAND -h</code> 或阅读 <code>github.com/kardianos/govendor/context</code> 查看源码包如何实现的。</p><table><thead><tr><th align="center">子命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">init</td><td>创建 <code>vendor</code> 目录和 <code>vendor.json</code> 文件</td></tr><tr><td align="center">list</td><td>列出&amp;过滤依赖包及其状态</td></tr><tr><td align="center">add</td><td>从 <code>$GOPATH</code> 复制包到项目 <code>vendor</code> 目录</td></tr><tr><td align="center">update</td><td>从 <code>$GOPATH</code> 更新依赖包到项目 <code>vendor</code> 目录</td></tr><tr><td align="center">remove</td><td>从 <code>vendor</code> 目录移除依赖的包</td></tr><tr><td align="center">status</td><td>列出所有缺失、过期和修改过的包</td></tr><tr><td align="center">fetch</td><td>从远程仓库添加或更新包到项目 <code>vendor</code> 目录(不会存储到 <code>$GOPATH</code>)</td></tr><tr><td align="center">sync</td><td>根据 <code>vendor.json</code> 拉取相匹配的包到 <code>vendor</code> 目录</td></tr><tr><td align="center">migrate</td><td>从其他基于 <code>vendor</code> 实现的包管理工具中一键迁移</td></tr><tr><td align="center">get</td><td>与 <code>go get</code> 类似，将包下载到 <code>$GOPATH</code>，再将依赖包复制到 <code>vendor</code> 目录</td></tr><tr><td align="center">license</td><td>列出所有依赖包的 LICENSE</td></tr><tr><td align="center">shell</td><td>可一次性运行多个 <code>govendor</code> 命令</td></tr></tbody></table><h6 id="govendor-状态参数"><a href="#govendor-状态参数" class="headerlink" title="govendor 状态参数"></a>govendor 状态参数</h6><table><thead><tr><th align="center">状态</th><th align="center">缩写</th><th>含义</th></tr></thead><tbody><tr><td align="center">+local</td><td align="center">l</td><td>本地包，即项目内部编写的包</td></tr><tr><td align="center">+external</td><td align="center">e</td><td>外部包，即在 <code>GOPATH</code> 中、却不在项目 <code>vendor</code> 目录</td></tr><tr><td align="center">+vendor</td><td align="center">v</td><td>已在 <code>vendor</code> 目录下的包</td></tr><tr><td align="center">+std</td><td align="center">s</td><td>标准库里的包</td></tr><tr><td align="center">+excluded</td><td align="center">x</td><td>明确被排除的外部包</td></tr><tr><td align="center">+unused</td><td align="center">u</td><td>未使用的包，即在 <code>vendor</code> 目录下，但项目中并未引用到</td></tr><tr><td align="center">+missing</td><td align="center">m</td><td>被引用了但却找不到的包</td></tr><tr><td align="center">+program</td><td align="center">p</td><td>主程序包，即可被编译为执行文件的包</td></tr><tr><td align="center">+outside</td><td align="center"></td><td>相当于状态为 <code>+external +missing</code></td></tr><tr><td align="center">+all</td><td align="center"></td><td>所有包</td></tr></tbody></table><p>支持状态参数的子命令有：<code>list</code>、<code>add</code>、<code>update</code>、<code>remove</code>、<code>fetch</code></p><h6 id="govendor的缺点"><a href="#govendor的缺点" class="headerlink" title="govendor的缺点"></a><code>govendor</code>的缺点</h6><ul><li><p>使用<code>vendor</code>的项目需要把该项目所有的依赖都下载到这个项目中的<code>vendor</code>目录下，这就会导致项目变的很庞大</p></li><li><p><code>vendor</code>不区分依赖包的版本，这就意味着可能出现不同的环境依赖了不同版本的包，很有可能导致编译出错</p></li></ul><h4 id="Go-mod-vendor"><a href="#Go-mod-vendor" class="headerlink" title="Go mod vendor"></a>Go mod vendor</h4><p>为了能够在离线的环境中也能够部署和应用程序，就保存了<code>vendor</code>目录；然后，执行如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><p>就可以将当前程序的依赖拷贝到<code>vendor</code>目录下，当程序中的包使用<code>go mod</code>下载不下来的时候，就可以引用<code>vendor</code>目录下的依赖了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;code&gt;go&lt;/code&gt;中有两个非常重要的环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GOROOT&lt;/code&gt;： &lt;code&gt;golang&lt;/code&gt;的安装路径，Linux 下默认会安装在&lt;code&gt;/usr/local/go&lt;/code&gt;之下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GOPATH&lt;/code&gt;：存放&lt;code&gt;SDK&lt;/code&gt;以外的第三方类库；收藏的可复用的代码，包含三个子目录： – src : 存放项目源码文件 – pkg : 编译后的包文件 – bin ：编译后生成的可执行文件&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Golang 基础知识" scheme="https://xinwazi.com/categories/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Golang 基础" scheme="https://xinwazi.com/tags/Golang-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Go 依赖管理" scheme="https://xinwazi.com/tags/Go-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-桥接模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-b9810bd9d5f8/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-b9810bd9d5f8/</id>
    <published>2022-04-27T02:36:06.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>桥接模式是一种结构型设计模式，可以将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用</p><span id="more"></span><h4 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h4><p>假如现在有一个 <code>Dog</code>类，而你在这个类的基础上扩展出了<code>Poodle Dog</code>和<code>Teddy Dog</code>这两种类型的<code>Dog</code>，之后又希望在添加新的类<code>Size</code>来区分不同大小的 <code>Dog</code>，那么此时你就需要添加新的类<code>SmallPoodleDog,BigPoodleDog,SmallTeddyDog</code>和<code>BigTeddyDog</code></p><p>当然，如果此时有需要一个<code>Color</code>类来区分<code>Dog</code>的颜色，那么这时候就要再进行扩展了，就会出现<code>RedSamllPoodleDog</code>这样的类；这时每增加一种维度的变化就需要增加很多的类，同样每增加一种品种的 <code>Dog</code>，也需要添加很多的类</p><p>但是，如果此时直接将这些<code>Small</code>类，<code>Red</code>类组合到<code>PoodleDog</code>中的话，又会增加代码的耦合性，每次<code>Red</code>类的变化都会引起<code>PoodleDog</code>的更改；</p><p>那如何才能解决这个问题呢？这就需要用到桥接模式</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>桥接模式就是明确识别系统中的独立变化的几个维度，拆分抽象和实现这两个独立的层次结构，降低程序中类的耦合度</p><p>也就是说，不能直接让<code>PooleDog</code>组合<code>Red</code>类，中间需要一个桥梁，而这个桥梁就是<code>Red,Blue</code>等同一维度的抽象表示，然后在这个<code>PooleDog</code>中组合这个抽象类，这样就将<code>PooleDog</code>和<code>Red</code>类分离开来了，<code>PooleDog</code>类的变化不会影响<code>Red</code>类，同样的<code>Red</code>的变化也不会影响<code>PooleDog</code>类</p><p>这就是设计模式中的依赖倒置原则：要针对接口进行编程，而不是针对实现进行编程；并且能够增加程序的扩展性，降低了程序之间的耦合性</p><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-b9810bd9d5f8/bridge.png" alt="bridge"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := &amp;BlueColor&#123;&#125;</span><br><span class="line">m := &amp;Medium&#123;&#125;</span><br><span class="line"></span><br><span class="line">c := &amp;Dog&#123;</span><br><span class="line">c: b,</span><br><span class="line">s: m,</span><br><span class="line">&#125;</span><br><span class="line">c.WithMediumBlue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">c color</span><br><span class="line">s Size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Dog)</span></span> WithMediumBlue() &#123;</span><br><span class="line">c.c.SetColor()</span><br><span class="line">c.s.SetSize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> color <span class="keyword">interface</span> &#123;</span><br><span class="line">SetColor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BlueColor <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BlueColor)</span></span> SetColor() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;color blue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Size <span class="keyword">interface</span> &#123;</span><br><span class="line">SetSize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Medium <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Medium)</span></span> SetSize() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;medium size&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当一个类的内部有两种或者多种不同维度的变化时，使用桥接模式可以解耦这些变化的维度，减少程序的耦合性，使代码结构更加的稳定</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>降低代码的耦合性</li><li>减少了不同维度造成的类的数量的增加</li><li>可以很好的对程序进行扩展</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>增加了代码的复杂度</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;桥接模式是一种结构型设计模式，可以将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="桥接模式" scheme="https://xinwazi.com/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-9e46328f333e/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-9e46328f333e/</id>
    <published>2022-04-24T03:02:05.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式是把一个类的接口变换为另一个类所期望的接口，使得原本因为接口不匹配而无法一起工作的类，变的可以正常调用</p><span id="more"></span><p>适配器别名有：Wrapper，Adapter，它是一种结构型设计模式，通过扩展原本不适配的类来满足特定的需求</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在计算机当中，有网卡驱动和显卡驱动等等，那这些驱动有什么作用呢？</p><p>作用就是为了能够适配操作系统；计算机发展过程中出现了越来越多的硬件厂商，比如：intel，amd，三星，华为等等，不同的厂商意味着不同的实现细节；</p><p>为了能够统一这种不断变化的局面，操作系统为不同的硬件提供了统一了接口，这些接口就是适配器，比如：网卡有网卡适配器，显卡有显卡适配器，而操作系统只是这些适配器通信，而不会管每个硬件具体实现细节；</p><p>而响应的各个硬件厂商也只需要为其出厂的对应的硬件实现相应的适配器就好了，实现的这些适配器就是所谓的驱动；这样的话，同一个操作系统就可以对应不同厂商的硬件了，只要该厂商提供了对应的适配器即可</p><h4 id="类图和示例代码"><a href="#类图和示例代码" class="headerlink" title="类图和示例代码"></a>类图和示例代码</h4><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-9e46328f333e/adapter.png" alt="adapter"></p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Target <span class="keyword">interface</span> &#123;</span><br><span class="line">Print(s <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adapter <span class="keyword">struct</span> &#123;</span><br><span class="line">at *adaptee</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Adapter)</span></span> Print(msg <span class="type">string</span>) &#123;</span><br><span class="line">a.at.PrintMsg(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> adaptee <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *adaptee)</span></span> PrintMsg(msg <span class="type">string</span>) &#123;</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAdapter</span><span class="params">()</span></span> *Adapter &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Adapter&#123;at:&amp;adaptee&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := NewAdapter()</span><br><span class="line">a.Print(<span class="string">&quot;this is adapter pattern&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细代码，可以参考 <a href="https://github.com/bad2cat/programming-essence/tree/main/designPattern">github</a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>扩展性</p><p>在原来的系统中进行了扩展，让其可以适配新的系统，并且不更改原系统的代码</p></li><li><p>复用性</p><p>两个系统接口不符合，但是功能相同，通过适配器只需要进行简单的变化就可以复用了，不需要再将已有的功能再实现一遍</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>复杂度</p><p>为了适配现有的接口，需要通过增加新的类型进行变换。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;适配器模式是把一个类的接口变换为另一个类所期望的接口，使得原本因为接口不匹配而无法一起工作的类，变的可以正常调用&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="适配器模式" scheme="https://xinwazi.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Golang-errors</title>
    <link href="https://xinwazi.com/golang/Golang-errors-8db0fed7c3cd/"/>
    <id>https://xinwazi.com/golang/Golang-errors-8db0fed7c3cd/</id>
    <published>2022-04-19T09:32:09.000Z</published>
    <updated>2022-06-17T07:48:55.121Z</updated>
    
    <content type="html"><![CDATA[<p><code>Golang</code>没有像<code>Java</code>那样的<code>try-catch</code>语句来捕获异常，而是通过<code>error</code>来表达程序中可能出现的错误</p><span id="more"></span><p><code>Golang</code>中的<code>error</code>是一个接口类型，所有实现了<code>Error() string</code>方法的类型都可以被认为是<code>error</code>；<code>error</code>的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在<code>Golang</code>中有一个内置<code>errors</code>库，里面有一个<code>errorString</code>实现了<code>error</code>接口，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，<code>errors</code>库还提供了一些函数用来进行错误的处理，接下来一一介绍</p><h4 id="errors-Unwrap-err-error-error"><a href="#errors-Unwrap-err-error-error" class="headerlink" title="errors.Unwrap(err error) error"></a>errors.Unwrap(err error) error</h4><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">u, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">Unwrap() <span class="type">error</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u.Unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能就是取出这个<code>error</code>包装的<code>error</code>，也就是说，如果<code>err</code> 中有一个方法为<code>Unwrap() error</code>，那么你调用<code>Unwrap(err)</code>就是给你返回<code>err.Unwrap()</code></p><p>下面是一个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WrapErr <span class="keyword">struct</span>&#123;</span><br><span class="line">    msg <span class="type">string</span></span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WrapErr)</span></span> Unwrap() <span class="type">error</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;err:%s&quot;</span>,w.msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := errors.New(<span class="string">&quot;This is a error&quot;</span>)</span><br><span class="line">    we := &amp;WrapErr&#123;</span><br><span class="line">    msg:<span class="string">&quot;This is err&quot;</span>,</span><br><span class="line">    err:err&#125;</span><br><span class="line">    <span class="keyword">if</span> newErr := we.Unwrap();newErr != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(newErr.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">err: This is a <span class="type">error</span></span><br></pre></td></tr></table></figure><h4 id="errors-Is-err-target-error-bool"><a href="#errors-Is-err-target-error-bool" class="headerlink" title="errors.Is(err,target error) bool"></a>errors.Is(err,target error) bool</h4><p>这个方法就是说在<code>err</code>这个错误链中是否有一个<code>error</code>与<code>target</code>相匹配，匹配的话就返回<code>true</code>，否则返回<code>false</code></p><p>那这个错误链是什么呢？就是在这个<code>err</code>上不断的调用<code>Unwrap(err)</code>方法返回的一系列<code>error</code>和这个<code>err</code>本身</p><p>那<code>error</code>和<code>target</code>匹配又是什么意思呢？它们的匹配有两种情况：</p><ol><li><code>err</code>和<code>target</code>相等，具有同样的值和同样的类型</li><li><code>err</code>中有一个方法<code>Is(error)</code>，并且有<code>err.Is(target)</code>为<code>true</code></li></ol><p>源代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err == target</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(<span class="type">error</span>) <span class="type">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider supporting target.Is(err). This would allow</span></span><br><span class="line"><span class="comment">// user-definable predicates, but also may allow for coping with sloppy</span></span><br><span class="line"><span class="comment">// APIs, thereby making it easier to get away with them.</span></span><br><span class="line"><span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="errors-As-err-target-interface-bool"><a href="#errors-As-err-target-interface-bool" class="headerlink" title="errors.As(err,target interface{}) bool"></a>errors.As(err,target interface{}) bool</h4><p>这个方法就是在<code>err</code>链中找到与<code>target</code>匹配的<code>error</code>，如果找到，则将这个<code>error</code>赋值给<code>target</code>并且返回<code>true</code></p><p>这个<code>err</code>链就是这个<code>err</code>本身和后续连续调用<code>Unwrap</code>方法得到的<code>error</code>组成</p><p><code>err</code>和<code>target</code>匹配是值，<code>err</code>的值是指针<code>target</code>类型的值，或者是有一个方法<code>As(interfalce)bool</code>使得<code>As(target)</code>返回为 <code>true</code></p><p>源代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err <span class="type">error</span>, target <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target cannot be nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">val := reflectlite.ValueOf(target) /</span><br><span class="line">typ := val.Type() <span class="comment">// 获取 target 具体类型</span></span><br><span class="line"><span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target must be a non-nil pointer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">targetType := typ.Elem()</span><br><span class="line"><span class="keyword">if</span> targetType.Kind() != reflectlite.Interface &amp;&amp; !targetType.Implements(errorType) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: *target must be interface or implement error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">err = Unwrap(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Golang&lt;/code&gt;没有像&lt;code&gt;Java&lt;/code&gt;那样的&lt;code&gt;try-catch&lt;/code&gt;语句来捕获异常，而是通过&lt;code&gt;error&lt;/code&gt;来表达程序中可能出现的错误&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="https://xinwazi.com/categories/golang/"/>
    
    
    <category term="golang" scheme="https://xinwazi.com/tags/golang/"/>
    
    <category term="error" scheme="https://xinwazi.com/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-生成器模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-70c66ed098cd/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-70c66ed098cd/</id>
    <published>2022-04-19T01:17:03.000Z</published>
    <updated>2022-06-17T07:48:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>生成器模式是一种创建型设计模式，使你能够分步骤创建一个复杂对象。该模式还允许你使用相同的创建代码生成不同形式和不同类型的对象，下面通过几个方面具体的说明。</p><span id="more"></span><h5 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h5><p>现在有一个复杂对象，包括很多的成员变量和嵌套对象，如何初始化这个复杂的对象呢？</p><p>通常就是将这些初始化代码放入一个构造方法当中，当然也有可能会放在多个不同的构造方法中</p><p>但是，如果将所有的参数都放到一个构造方法中，那么就会有很多冗余的参数；而要是使用多个不同的构造方法的话，不同的参数组合会产生数量不可控的构造方法</p><p>不管是使用一个构造方法还是使用多个构造方法，都会在一定程度上增加构造这个对象复杂度，并且会导致这个对象很难扩展，下面使用一个具体的案例来解释一下</p><p>比如，现在要构建一个<code>House</code>对象，它包含的基本属性有：door，window，roof，wall，floor，light 等，并且它也可以包含一些其他的设施，如：heating，electricity，gas，yard，pool，soft 等等，那如何构造这个对象呢？如何为不同的人构造不同的<code>House</code>呢？</p><p>最简单的就是在这个<code>House</code>对象的基础上进行扩展，添加<code>pool</code>，<code>soft</code>，<code>heating</code>等等这些对象；最简单的方法就是添加一个超级构造方法将所有的这些属性和嵌套对象都包含进来，但是，这样的话即便构造一个简单<code>House</code>也需要传入很多的构造参数，尽管大部分构造参数根本用不到</p><p>当然，还有一种方法就是添加多个构造方法，不同的构造方法构造不同形式的<code>House</code>，但这随着<code>House</code>的属性不断增加，就会导致构造方法的数量不可控了，并且使得代码的扩展性极差</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>生成器模式建议将对象构造的代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象当中；将对象的构造划分为一组步骤，如：<code>buildWall()</code>创建墙面，<code>buildDoor</code>创建门等等；</p><p>每次创建对象的时候，你可以通过生成器执行一系列步骤；重点就是，你无需调用所有的步骤，只需要调用创建特定对象的那些步骤即可</p><p>当然，对于同一类产品可能会有不同的形式，比如：木制的<code>Door</code>和铁制的<code>door</code>；在这种情况下，就可以创建多个不同的生成器，用不同方式实现一组相同的创建步骤，然后在客户端使用这些生成器创建不同形式的对象；比如：<code>WoodHouseBuilder</code>创建木制的房子，<code>IronHouseBuilder</code>则会给你返回一个铁制的房子</p><h5 id="主管"><a href="#主管" class="headerlink" title="主管"></a>主管</h5><p>虽然现在解决了超级构造函数的问题，但是客户端还是得知道构建一个<code>House</code>对象的具体步骤；那有没有一种方法直接生成一个你想要的房子呢？</p><p>答案是有的，就是通过主管类，比如：你现在想要一个木制的房子，那么主管类会将一系列创建木制房子的步骤封装起来，当你使用主管类调用时，主管类就会给你返回给你一个木制的房子，这样就不需要再去了解构建一个木制房子的具体细节了</p><p>这样，主管类屏蔽了构建一个木制类房子的细节，真正的做到了客户端和具体的构建对象之间的解耦，更加的利于程序的扩展了</p><h5 id="生成器模式结构图和代码"><a href="#生成器模式结构图和代码" class="headerlink" title="生成器模式结构图和代码"></a>生成器模式结构图和代码</h5><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-70c66ed098cd/generator.png" alt="generator"></p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> House <span class="keyword">struct</span> &#123;</span><br><span class="line">Wall    <span class="type">string</span></span><br><span class="line">Door    <span class="type">string</span></span><br><span class="line">Window  <span class="type">string</span></span><br><span class="line">Heating <span class="type">string</span></span><br><span class="line">Yard    *Yard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Yard <span class="keyword">struct</span> &#123;</span><br><span class="line">Size <span class="type">int</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newYard</span><span class="params">(size <span class="type">int</span>, name <span class="type">string</span>)</span></span> *Yard &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Yard&#123;</span><br><span class="line">Size: size,</span><br><span class="line">Name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *House)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;Door:%s,Wall:%s,Window:%s,Heating:%s&quot;</span>,h.Door,h.Wall,h.Window,h.Heating)</span><br><span class="line"><span class="keyword">if</span> h.Yard != <span class="literal">nil</span>&#123;</span><br><span class="line">s = fmt.Sprintf(<span class="string">&quot;%s,yard size:%d,yard name:%s&quot;</span>,s,h.Yard.Size,h.Yard.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HouseBuilder</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HouseBuilder <span class="keyword">interface</span> &#123;</span><br><span class="line">BuildWall()</span><br><span class="line">BuildYard()</span><br><span class="line">BuildDoor()</span><br><span class="line">BuildWindow()</span><br><span class="line">BuildHeating()</span><br><span class="line">    <span class="comment">// 如果是同一类型不同形式的对象，则在此处声明获取产品的方法即可</span></span><br><span class="line">    <span class="comment">// 如果是不同类型的对象，则需要在具体的 builder 中添加获取该类型产品的方法</span></span><br><span class="line">GetHouse() *House</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// woodBuilder use build wood house</span></span><br><span class="line"><span class="keyword">type</span> woodBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">wall    <span class="type">string</span></span><br><span class="line">door    <span class="type">string</span></span><br><span class="line">window  <span class="type">string</span></span><br><span class="line">heating <span class="type">string</span></span><br><span class="line">yard    *Yard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWoodBuilder</span><span class="params">()</span></span> HouseBuilder &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;woodBuilder&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *woodBuilder)</span></span> BuildWall() &#123;</span><br><span class="line">w.wall = <span class="string">&quot;white wall&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *woodBuilder)</span></span> BuildDoor() &#123;</span><br><span class="line">w.door = <span class="string">&quot;red wood&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *woodBuilder)</span></span> BuildYard() &#123;</span><br><span class="line">w.yard = newYard(<span class="number">10</span>,<span class="string">&quot;wood yard&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *woodBuilder)</span></span> BuildWindow() &#123;</span><br><span class="line">w.window = <span class="string">&quot;wood window&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *woodBuilder)</span></span> BuildHeating() &#123;</span><br><span class="line">w.heating = <span class="string">&quot;simonzi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *woodBuilder)</span></span> GetHouse() *House &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;House&#123;</span><br><span class="line">Wall:    w.wall,</span><br><span class="line">Door:    w.door,</span><br><span class="line">Window:  w.window,</span><br><span class="line">Heating: w.heating,</span><br><span class="line">Yard:    w.yard,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type director struct &#123;</span><br><span class="line">builder HouseBuilder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newDirector(builder HouseBuilder) *director &#123;</span><br><span class="line">return &amp;director&#123;builder: builder&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *director) SetBuilder(builder HouseBuilder) &#123;</span><br><span class="line">d.builder = builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *director) buildWoodHouse() *House &#123;</span><br><span class="line">d.builder.BuildDoor()</span><br><span class="line">d.builder.BuildHeating()</span><br><span class="line">d.builder.BuildWall()</span><br><span class="line">d.builder.BuildWindow()</span><br><span class="line">d.builder.BuildYard()</span><br><span class="line">return d.builder.GetHouse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">houseBuilder := newWoodBuilder()</span><br><span class="line">director := newDirector(houseBuilder)</span><br><span class="line"></span><br><span class="line">house := director.buildWoodHouse()</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%s&quot;,house)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面创建<code>House</code>对象是通过指定的<code>HouseBuilder</code>创建的，<code>House</code>的参数是默认的；如果你想要动态参数，那么就将这些参数传入到<code>WoodBuild</code>就可以了，因为在这已经确定了这些参数是创建这个所必须的，所以不会出现参数的冗余问题；</p><p>对于扩展性而言，对于新增的字段则只需要再新加一个新的生成器就可以了，这样就不需要更改之前的代码就完成了程序的扩展了</p><h5 id="注：具体的代码示例可以参考这里"><a href="#注：具体的代码示例可以参考这里" class="headerlink" title="注：具体的代码示例可以参考这里"></a>注：具体的代码示例可以参考<a href="https://github.com/bad2cat/programming-essence/tree/main/designPattern">这里</a></h5>]]></content>
    
    
    <summary type="html">&lt;p&gt;生成器模式是一种创建型设计模式，使你能够分步骤创建一个复杂对象。该模式还允许你使用相同的创建代码生成不同形式和不同类型的对象，下面通过几个方面具体的说明。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="生成器模式" scheme="https://xinwazi.com/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-df9309fd2954/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-df9309fd2954/</id>
    <published>2022-04-18T01:32:42.000Z</published>
    <updated>2022-06-17T07:48:55.121Z</updated>
    
    <content type="html"><![CDATA[<p>单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点</p><span id="more"></span><h6 id="为什么需要控制实例的个数"><a href="#为什么需要控制实例的个数" class="headerlink" title="为什么需要控制实例的个数"></a>为什么需要控制实例的个数</h6><p>最常见的原因就是为了控制某些共享资源的访问（如：数据库链接，全局的日志等）</p><p>单例模式会始终维持只有一个实例，首先会创建一个该对象的全局变量，然后在第一次调用时创建该对象实例赋值给这个全局变量，之后每次新建时都只是返回之前的这个实例，而不是新建一个该对象的实例</p><h6 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h6><p>单线程和多线程中实现单例模式的方式有一点不同，这是因为多线程时需要解决同步的问题，所以需要在创建对象时加锁，保证只有一个实例被创建</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := GetSingleton()</span><br><span class="line">s2 := GetSingleton()</span><br><span class="line"></span><br><span class="line">fmt.Println(s1 == s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> staticSingleton *Singleton</span><br><span class="line"><span class="keyword">var</span> lock = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSingleton</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">if</span> staticSingleton == <span class="literal">nil</span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> staticSingleton == <span class="literal">nil</span> &#123;</span><br><span class="line">staticSingleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> staticSingleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="https://xinwazi.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Golang 版本更新</title>
    <link href="https://xinwazi.com/Golang/Golang-%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0-ff6968af57e9/"/>
    <id>https://xinwazi.com/Golang/Golang-%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0-ff6968af57e9/</id>
    <published>2022-04-15T08:09:54.000Z</published>
    <updated>2022-06-17T07:48:55.121Z</updated>
    
    <content type="html"><![CDATA[<p>在 Github 下载了一个库，结果这个库要求<code>Go 1.17.x</code>以上的版本，一想还是更新版本吧</p><span id="more"></span><p>之前的版本是 <code>1.15.6</code>，现在打算更新到<code>1.17.9</code>；</p><p>打开<code>Golang</code>的<a href="https://golang.google.cn/dl/">官网</a>，找到对应的安装包<code>[go1.17.9.linux-amd64.tar.gz](https://golang.google.cn/dl/go1.17.9.linux-amd64.tar.gz)</code></p><blockquote><p>注： 当时不小心下载成了 arm 的安装包，结果安装之后一直报”二级制格式不正确”，刚开始还很纳闷，结果后来一看，才知道犯了这么低级的错误</p></blockquote><p>下载完安装包之后，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">sudo -rf go/</span><br></pre></td></tr></table></figure><p>进入到<code>/usr/local</code>目录下，移除之前的<code>golang</code>版本；</p><p>然后将新下载的安装包移动的<code>/usr/local</code>目录下面；接下执行命令解压即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf go1.17.9.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解析之后执行一下<code>go version</code>，看看是否安装成功就可以了</p><h6 id="问题：但是这有个问题，就是升级到Go1-17-x之后，在goland中设置Go-root时会报一个错误，如下："><a href="#问题：但是这有个问题，就是升级到Go1-17-x之后，在goland中设置Go-root时会报一个错误，如下：" class="headerlink" title="问题：但是这有个问题，就是升级到Go1.17.x之后，在goland中设置Go root时会报一个错误，如下："></a>问题：但是这有个问题，就是升级到<code>Go1.17.x</code>之后，在<code>goland</code>中设置<code>Go root</code>时会报一个错误，如下：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the selected directory is not a valid home for go sdk 1.17</span><br></pre></td></tr></table></figure><p>查了一下找到了一个<a href="https://stackoverflow.com/questions/19108421/the-selected-directory-is-not-a-valid-home-for-go-sdk">解决方案</a>，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/src/runtime/internal/sys/</span><br><span class="line">sudo vim zversion.go</span><br></pre></td></tr></table></figure><p>打开这个<code>golang</code>文件之后，在文件最后面添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const TheVersion = `go1.17.9` // 这个地方版本就是你安装的版本</span><br></pre></td></tr></table></figure><p>然后重新配置<code>GoRoot</code>发现就好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Github 下载了一个库，结果这个库要求&lt;code&gt;Go 1.17.x&lt;/code&gt;以上的版本，一想还是更新版本吧&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://xinwazi.com/categories/Golang/"/>
    
    
    <category term="Golang 版本更新" scheme="https://xinwazi.com/tags/Golang-%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"/>
    
    <category term="Golang 基础" scheme="https://xinwazi.com/tags/Golang-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go初始化过程</title>
    <link href="https://xinwazi.com/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B-70e8136e1cc3/"/>
    <id>https://xinwazi.com/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B-70e8136e1cc3/</id>
    <published>2022-04-08T09:44:27.000Z</published>
    <updated>2022-06-17T07:48:55.121Z</updated>
    
    <content type="html"><![CDATA[<p>在一个<code>Go</code>程序的初始化过程中一般会涉及到如下的一些元素：包，常量，变量，init()，main() 等；程序的初始化一般是从<code>main</code>包开始的；</p><span id="more"></span><p>如果<code>main</code>中<code>import</code>了其他的包，那么就会按照<code>import</code>的顺寻优先初始化这些引入的包；</p><p>在同一个包下面的<code>.go</code>文件会按照文件名的顺序初始化；在一个<code>.go</code>文件中，初始化的顺序是：常量，变量，init() 函数；如果在这个<code>.go</code>文件下面有多个<code>init()</code>函数，那么就会按照出现的顺序执行</p><p>等到引入的包初始化完成之后，就会继续初始化<code>main</code>包了，<code>main</code>包总是最后一个被初始化的；同一个包不管被引入几次，都只会被初始化一次</p><p>因为<code>Go</code>不允许循环依赖，所以不会出现<code>A-&gt;B-&gt;C-&gt;A</code>的情况；<code>Go</code>的初始化过程如下图所示：</p><p><img src="/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B-70e8136e1cc3/go_init_order.png" alt="Golang程序初始化过程"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个&lt;code&gt;Go&lt;/code&gt;程序的初始化过程中一般会涉及到如下的一些元素：包，常量，变量，init()，main() 等；程序的初始化一般是从&lt;code&gt;main&lt;/code&gt;包开始的；&lt;/p&gt;</summary>
    
    
    
    <category term="Golang 基础知识" scheme="https://xinwazi.com/categories/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Golang 基础" scheme="https://xinwazi.com/tags/Golang-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Golang 程序初始化顺序" scheme="https://xinwazi.com/tags/Golang-%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo按年月分类博客</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo%E6%8C%89%E5%B9%B4%E6%9C%88%E5%88%86%E7%B1%BB%E5%8D%9A%E5%AE%A2-f49199d2b5bd/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo%E6%8C%89%E5%B9%B4%E6%9C%88%E5%88%86%E7%B1%BB%E5%8D%9A%E5%AE%A2-f49199d2b5bd/</id>
    <published>2022-04-06T08:59:25.000Z</published>
    <updated>2022-06-17T07:48:55.121Z</updated>
    
    <content type="html"><![CDATA[<p>这两天发现一个问题，就是博客的量慢慢的变多了，但是所有的博客还是在<code>_post</code>这个文件夹下面，感觉乱糟糟的，那有什么办法能进行组织管理呢？</p><span id="more"></span><p>现在找到了两种方式来对<code>_post</code>中的文章进行管理</p><h4 id="使用配置new-post-name"><a href="#使用配置new-post-name" class="headerlink" title="使用配置new_post_name"></a>使用配置<code>new_post_name</code></h4><p>在<code>hexo</code>的<a href="https://hexo.io/zh-cn/docs/writing.html">官方文档中</a>找到了一个配置，通过这个配置就可以对文章进行有序的管理；</p><p>打开根目录下面的<code>config.yml</code>文件，在文件中有一个配置项为<code>new_post_name</code>，默认值：<code>:title.md</code>，这个<code>:title</code>就是你创建的文章的名称；官方文档中说可以通过更改这个配置来管理你的文章</p><p>通过命令<code>hexo new post &quot;title&quot;</code>创建的文章，默认就是在<code>/source/_post</code>目录下面，现在更改这个配置项为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year/:month/:title.md</span><br></pre></td></tr></table></figure><p>这样你在通过<code>hexo new post &quot;title&quot;</code>创建文章之后，文章就会在目录<code>/source/_post/2022/04/</code>下面了，这样就可以按照月份对文章进行分类了；当然，你也可以设置<code>new_post_name: :year/:title.md</code>按年进行分类，或者设置为<code>new_post_name: :year/:month:/day/:title.md</code>按天分类</p><p>有一个问题：现在我想按照<code>category</code>分类，但是<code>category</code>是创建之后才指定的，那么如何才能在创建的时候指定<code>category</code>，然后按照<code>category</code>分类呢？</p><h4 id="使用命令参数-path"><a href="#使用命令参数-path" class="headerlink" title="使用命令参数--path"></a>使用命令参数<code>--path</code></h4><p>第二种方式就是指定文章创建的路径，比如：创建一个<code>test/test.md</code>的文档，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post --path test/test</span><br></pre></td></tr></table></figure><p>这样，生成的文件就会在<code>source/_post/test</code>目录中了，而不是在<code>_post</code>目录下面了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天发现一个问题，就是博客的量慢慢的变多了，但是所有的博客还是在&lt;code&gt;_post&lt;/code&gt;这个文件夹下面，感觉乱糟糟的，那有什么办法能进行组织管理呢？&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="按年月管理博客" scheme="https://xinwazi.com/tags/%E6%8C%89%E5%B9%B4%E6%9C%88%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客中的图片不显示的解决方案</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-ee172ebfb43e/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-ee172ebfb43e/</id>
    <published>2022-04-06T06:33:44.000Z</published>
    <updated>2022-06-17T07:48:55.129Z</updated>
    
    <content type="html"><![CDATA[<p>这两天用 <code>hexo</code>搭建了一个个人博客，第一次写完文章之后，发现用<code>MarkDown</code>的方式引用图片之后，图片在博客中不能够正常的显示。</p><span id="more"></span><p>一开始的时候，用的就是如下的这种图片引用的方式来引用图片的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![img描述](imgPath)</span><br></pre></td></tr></table></figure><p>但是这种方式好像只是在本地起作用，当生成博客系统推送到<code>Github</code>上去之后，图片就显示不了了；</p><p>没办法，还得仔细再看看<a href="https://hexo.io/zh-cn/docs/asset-folders">Hexo 官方文档</a>；下面引用文档中的内容：</p><blockquote><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p></blockquote><p>现在才知道，也就是说如果你有少量的图片那么就直接放到<code>source/images</code>目录下面，然后通过<code>md</code>的图片引用方式就可以了</p><p>但是，如果你想按照每个文章来整理对应文章的资源的话，就需要进行一些设置了；打开根目录下面<code>config.yml</code>文件，找到配置项<code>post_asset_folder</code> 设置问<code>true</code></p><p>打开这个功能之后，创建新文章时就会自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们；</p><p>当然，当你用了这种方式之后，就不能用<code>md</code>的方式来引用图片了，下面是官方的说明：</p><blockquote><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p></blockquote><p>也就是说，你需要一个插件来解决这个问题；在<code>hexo3</code>中不需要自己安装插件，这个插件已经被加入到了核心代码；你只需要通过一段代码就能够引用图片了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>现在举个例子，假如你用<code>hexo new post &quot;FisrtBlog&quot;</code>创建了一篇名为<code>FisrtBlog</code>的文章，同时会在该目录下创建一个名称为<code>FirstBlog</code>的文件夹；当你需要在文章中引入图片时，就可以用如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img img.png FisrtBlog] %&#125;</span><br></pre></td></tr></table></figure><p><code>img.png</code>就是图片的名称，<code>FisrtBlog</code>是图片的描述；这个图片需要放到<code>FisrtBlog</code>下面，完成之后，再次部署博客到<code>Github</code>之后，打开网站就能够看到引用的图片了</p><h5 id="那如何才能试用MarkDone方式呢"><a href="#那如何才能试用MarkDone方式呢" class="headerlink" title="那如何才能试用MarkDone方式呢"></a>那如何才能试用<code>MarkDone</code>方式呢</h5><p>有时候使用这种方式会感觉很麻烦，假如你想在其他平台也发布这篇文章，那么你还得再改回去；所以还有一种就是通过配置来支持<code>md</code>的方式，再次打开<code>config.yml</code>,然后更改如下的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>设置之后，资源文件夹下面的图片会自动的解析到 <code>post path</code>下面；例如：<code>img.jpg</code>在<code>/2020/01/02/foo/image.jpg</code>，那<code>/2020/01/02/foo/</code>就是<code>post</code>的对应的资源目录，使用<code>![](image.jpg)</code>之后就会自动的将该图片地址渲染为<code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>；这样使用 <code>md</code>方式也就能够正确的引用图片了</p><p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-ee172ebfb43e/theEnd.jpg" alt="The End"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天用 &lt;code&gt;hexo&lt;/code&gt;搭建了一个个人博客，第一次写完文章之后，发现用&lt;code&gt;MarkDown&lt;/code&gt;的方式引用图片之后，图片在博客中不能够正常的显示。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo 博客" scheme="https://xinwazi.com/tags/hexo-%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="博客中图片不显示的问题" scheme="https://xinwazi.com/tags/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/</id>
    <published>2022-04-06T05:21:05.000Z</published>
    <updated>2022-06-17T07:48:55.133Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式是一种创建型模式，其在父类提供了一个创建对象的方法，允许子类来决定实例化对象的类型；下面通过一个具体的问题进行说明；</p><span id="more"></span><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在本地有一个快递公司，使用卡车进行货物的运输; 运输的方式就是实例化<code>Truck</code>类，然后调用 <code>Truck</code>类的<code>Delivery</code>方法就可以完成运输了；</p><p>现在公司要扩张业务，需要支持航空运输和轮船运输，那如何能够优雅的应对公司业务的不断的扩张呢？</p><p>要是按照之前的方式，直接添加<code>Ship</code>和<code>Air</code>类的话，就需要更改客户端代码；这样一来，客户端的代码不但变的越来越复杂，并且紧紧的与具体对象的类型耦合在了一起；</p><p>如果之后业务不断的增加，会使得客户端代码越来越复杂，而且某一个类的任何一点变化，都需要更改客户端的代码，慢慢的客户端代码就会变的越来越难以维护，就会严重的影响公司的业务的扩张</p><p>下面提供了两种方案，来应对快递公司的这种不断变化的业务模型。</p><h3 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h3><p>首先需要解决的就是客户端代码和对象的类型耦合的问题；我们定义一个<code>Transport</code>接口，在接口类型中声明一个<code>Delivery</code>方法; </p><p>然后让不同的运输类实现这个接口，这样对于客户端而言只需要传入具体的运输方式，就可以创建指定的运输对象了，这样客户端代码就不会和对象的具体类型耦合在一起了</p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/factory_simple.png" class="" title="Factory-pattern"><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type TransportSimple interface &#123;</span><br><span class="line">Delivery() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CreateTransport(typ string) TransportSimple &#123;</span><br><span class="line">switch typ &#123;</span><br><span class="line">case &quot;truck&quot;:</span><br><span class="line">return &amp;Truck&#123;&#125;</span><br><span class="line">case &quot;airPlane&quot;:</span><br><span class="line">return &amp;AirPlane&#123;&#125;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Truck struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (t *Truck) Delivery() string &#123;</span><br><span class="line">return fmt.Sprintf(&quot;use truck delivery...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AirPlane struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (a *AirPlane) Delivery() string &#123;</span><br><span class="line">return fmt.Sprintf(&quot;use airplane delivery...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端代码</span><br><span class="line">func main() &#123;</span><br><span class="line">t := CreateTransport(&quot;truck&quot;)</span><br><span class="line">t.Delivery()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随着公司运输方式的增加，公司运输的货物也越来越多，但是也收到了不少的差评；因为很多生鲜类的货物，到了用户手里都变质了；还有货物到了快递公司也是随便的堆放；</p><p>公司为了解决这些问题，又增加了分类<code>Category</code>和存储<code>Store</code>功能，分类就是在货物到公司后，对货物进行分类；存储的话就是根据分类的结果，对货物分别存储，等到有合适的路线再取出来运输</p><p>但是之前的方案好像不能够很好的解决这两种功能的加入，所以公司想有没有一个更加合适的方案，既能应对运输线路的增加，又能解决业务扩张带来的这些问题呢？</p><h3 id="抽象工厂设计模式"><a href="#抽象工厂设计模式" class="headerlink" title="抽象工厂设计模式"></a>抽象工厂设计模式</h3><p>简单工厂模式只能应对单一产品的变化，一旦产品种类增加之后，简单工厂模式就不能够优雅的应对了；那么此时又有了一个改进的工厂模式：抽象工厂设计模式</p><p>在抽象工厂设计模式中，首先需要定义一个<code>AbstractFactory</code>接口，在这个接口中定义创建不同产品的方法；比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type AbstractFactory interface&#123;</span><br><span class="line">    CreateProductA() ProductA</span><br><span class="line">    CreateProductB() ProductB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，定义不同的工厂类型，比如：<code>FactoryA</code>只生产<code>A</code>类型相关的一些列产品，而<code>FactoryB</code>只生产<code>B</code>类型相关的一系列产品</p><p>之前的简单工厂模式只能生产出单一功能不同类型的产品，而抽象工厂模式可以生产出多功能，并且各种不同类型的产品；</p><p>这就相当于多条生产线，每条生产线生产统一类型相关的一系列产品；客户端只需要创建一个<code>AbstractFactory</code>的实例就可以对货物进行分类，存储，运输等功能了；并且如果之后有其他的功能的话，只需要添加到这个工厂类中就可以了；下面是类图示例：</p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/fac_complex.png" class="" title="Factory-pattern"><p>代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Factory interface &#123;</span><br><span class="line">CreateTransport() TransportSimple</span><br><span class="line">CreateStore() Store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CreatorA struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorA) CreateTransport() TransportSimple &#123;</span><br><span class="line">return &amp;Truck&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorA) CreateStore() Store &#123;</span><br><span class="line">return &amp;ColdStore&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CreatorB struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorB) CreateTransport() TransportSimple &#123;</span><br><span class="line">return &amp;AirPlane&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorB) CreateStore() Store &#123;</span><br><span class="line">return &amp;HotStore&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CreateFactory(typ string) Factory &#123;</span><br><span class="line">switch typ &#123;</span><br><span class="line">case &quot;coldWithTruck&quot;:</span><br><span class="line">return &amp;CreatorA&#123;&#125;</span><br><span class="line">case &quot;hotWithAirPlane&quot;:</span><br><span class="line">return &amp;CreatorB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就能够应对公司业务的不断变化了; 可在 <a href="https://github.com/bad2cat/programming-essence/tree/main/designPattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">Github 中查看完整代码示例</a></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>你可以避免创建者和具体产品之间的紧密耦合。</li><li>单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li><li>开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;工厂模式是一种创建型模式，其在父类提供了一个创建对象的方法，允许子类来决定实例化对象的类型；下面通过一个具体的问题进行说明；&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="design pattern" scheme="https://xinwazi.com/tags/design-pattern/"/>
    
    <category term="原型模式" scheme="https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-0b54b6ca657c/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-0b54b6ca657c/</id>
    <published>2022-03-31T10:35:53.000Z</published>
    <updated>2022-06-17T07:48:55.133Z</updated>
    
    <content type="html"><![CDATA[<p>原型就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人</p><span id="more"></span><h4 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h4><p>原型模式是一种创建型设计模式，它能够帮助你克隆指定的对象，并且无需和对象所属的类耦合，下面通过具体的问题来说明该设计模式的应用场景</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>假如现在有一个对象<code>User</code>，要复制和这个<code>User</code>完全一样的对象要怎么做呢？首先，需要新建一个同类对象，然后将<code>User</code>对象的所有成员变量复制到新对象就好了，但现在有两个问题：</p><ol><li><p>如果有组合类型，那就需要遍历组合类型的成员变量来完成复制；如果变量是私有变量，那么只能再调用获取私有变量的方法才能够实现私有变量的复制；</p><p>按照这种方式进行复制的话，这段代码就和对象所属的类产生的紧密的耦合；原对象所属的类发生的任何变化，都要在此处进行相应的更改；如果这种复制代码的操作很多的话，代码就会变的很难维护了</p></li><li><p>假如<code>User</code>是某个对象所实现的接口类型，就是指在某个方法中参数为接口而传入的具体对象的时候，方法中你拿到的是接口的类型，而不知道对象的具体类型，这种情况下要怎么实现复制呢？</p></li></ol><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>上面的问题会在代码中引入对象所属的类，导致两者产生了紧密的耦合；原型设计模式就是将克隆的过程委派给了被克隆的实际对象，这样只需要调用该对象的克隆方法就能够实现复制，而不需要和对象所属的类耦合在一起</p><p>首先，原型设计模式为所有支持克隆的对象声明了一个通用的接口，接口中通常只有一个 <code>Clone()</code>的方法；然后，实体类实现该接口，在该方法中完成对象的复制操作；最后客户端调用的时候只需要调用该对象的<code>Clone()</code>方法就能够获取到一个和该对象相同的一个对象</p><p>所有的类对<code>Clone()</code>方法的实现都很类似；该方法首先就是创建该类的一个对象，然后将原对象的所有成员变量赋值给新的对象就好了，如果有组合类型，那么调用组合类型的<code>Clone()</code>方法就好了；按照这种方式就可以实现对私有变量的复制了</p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-0b54b6ca657c/01.png" class="" title="Prototype-pattern"><p>支持克隆的对象就是原型对象，当你的对象有几十种成员变量和几十种组合类型时，对其进行克隆甚至能够代替子类的构造；比如：创建一系列不同类型的对象用不同的方式进行配置，如果所需对象和预先配置的对象相同，那么就可以使用<code>Clone()</code>方法进行构造</p><h4 id="原型设计模式代码示例"><a href="#原型设计模式代码示例" class="headerlink" title="原型设计模式代码示例"></a>原型设计模式代码示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Prototype <span class="keyword">interface</span> &#123;</span><br><span class="line">Clone() Prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Color <span class="type">string</span></span><br><span class="line">Age   <span class="type">int</span></span><br><span class="line">Kind  <span class="type">string</span></span><br><span class="line">which <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Clone() Prototype &#123;</span><br><span class="line">newCar := &amp;Car&#123;</span><br><span class="line">Name:  c.Name,</span><br><span class="line">Color: c.Color,</span><br><span class="line">Age:   c.Age,</span><br><span class="line">Kind:  c.Kind,</span><br><span class="line">which: c.which,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newCar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Car&#123;</span><br><span class="line">Name:  <span class="string">&quot;BB&quot;</span>,</span><br><span class="line">Color: <span class="string">&quot;White&quot;</span>,</span><br><span class="line">Age:   <span class="number">1</span>,</span><br><span class="line">Kind:  <span class="string">&quot;BA&quot;</span>,</span><br><span class="line">which: <span class="string">&quot;Me&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&amp;c)</span><br><span class="line">cc := c.Clone()</span><br><span class="line">fmt.Println(reflect.TypeOf(cc))</span><br><span class="line">fmt.Println(cc)</span><br><span class="line">fmt.Println(&amp;cc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原型注册表"><a href="#原型注册表" class="headerlink" title="原型注册表"></a>原型注册表</h4><p>原型注册表就是将所有的原型对象存储起来，然后提供一种访问原型对象的方法；比如：可以使用<code>HashMap</code>作为存储，然后将对象的名称作为<code>key</code>，对象实例作为值存储起来；使用的时候通过对象的名称就可以获取到原型对象了</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><h6 id="独立于当前代码"><a href="#独立于当前代码" class="headerlink" title="独立于当前代码"></a>独立于当前代码</h6><p>假如当前代码中需要复制一些对象，同时又希望代码能够独立于这些对象所属的类，则就可以使用原型设计模式；</p><p>原型设计模式提供了一个通用的接口，客户端通过使用这一个通用的接口来完成与克隆对象的交互，使得客户端代码与其克隆对象的类独立开</p><h6 id="初始化子类"><a href="#初始化子类" class="headerlink" title="初始化子类"></a>初始化子类</h6><p>如果子类的区别仅在于其对象的初始化方式，那就可以使用该类来减少子类的数量。因为别人创建这些子类的目的就是为了创建特定类型的对象；在原型模式中，可以使用一系列预生成的，各种类型的对象作为原型；客户端就不需要对子类进行初始化了，只需要找到合适的原型进行克隆就好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原型就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="design pattern" scheme="https://xinwazi.com/tags/design-pattern/"/>
    
    <category term="原型模式" scheme="https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客(5) - 集成GithubAction</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/</id>
    <published>2022-03-17T10:55:35.000Z</published>
    <updated>2022-06-17T07:48:55.137Z</updated>
    
    <content type="html"><![CDATA[<p>这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &#x27;Fisrt Blog&#x27;</span><br></pre></td></tr></table></figure><span id="more"></span><p>执行完命令之后就会在<code>Blog/source/_posts</code>下面生成一个<code>md</code>文档了，然后在该文档中写入想发表的内容之后保存；同样的执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后就可以发布博客到<code>Github</code>了，通过之前购买的域名刷新就可以看到发表的博客了；如果每次都这样写博客会很难受，并且如果更换了电脑，需要重新再打造之前的环境了。那如何解决这个问题呢？</p><h4 id="Hexo-持续集成GithubAction"><a href="#Hexo-持续集成GithubAction" class="headerlink" title="Hexo 持续集成GithubAction"></a>Hexo 持续集成<code>GithubAction</code></h4><p>为了能够在各个地方都很容易的发表博客，那就需要实现<code>Hexo</code>持续集成；现在有两种集成的方式：</p><h5 id="持续集成-Travis-CI"><a href="#持续集成-Travis-CI" class="headerlink" title="持续集成 Travis CI"></a>持续集成 <code>Travis CI</code></h5><p>这种方式可以参考，Hexo <a href="https://hexo.io/zh-cn/docs/github-pages">官方文档</a></p><h5 id="持续集成-Github-Action"><a href="#持续集成-Github-Action" class="headerlink" title="持续集成 Github Action"></a>持续集成 <code>Github Action</code></h5><p>说明：Github Action 是<code>Github</code> 的一种执行任务的脚本，将<code>hexo</code>持续集成<code>Gihub Action</code>之后，需要将本地的博客系统<code>push</code>到<code>Github</code>的一个仓库中（也可以是仓库<code>&lt;username&gt;.github.io</code>的一个分支）；之后每次写博客时，只需要将这个博客系统拉到本地，写完之后<code>push</code>上去即可，脚本<code>Github Actions</code>就会自动发布博客的更新</p><p>下面就介绍使用<code>Github Action</code>持续集成的例子</p><ol><li><h6 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h6><p>本文选择将博客系统推送的一个新的分支，所以需要创建一个新的仓库，可以将这个仓库设置为<code>private</code>，因为没必要让别人看到博客的源码，新建的仓库为<code>blog</code></p></li><li><h6 id="推送源码，设置-secret"><a href="#推送源码，设置-secret" class="headerlink" title="推送源码，设置 secret"></a>推送源码，设置 secret</h6><p>在本地的跟目录下面，打开<code>git bash</code>界面，将本地的源码推送到<code>blog</code>仓库；</p><p>注：在这里要注意一点，之前下载主题是，在主题那个文件夹会有一个<code>.git</code>隐藏文件，在你推送之前一定要把这个<code>.git</code>文件删除掉，否则推送上去之后主题就会失效</p><p>接下来，打开<code>blog</code>仓库的<code>setting</code>，添加<code>secret</code>，如下：</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/01.png" class="" title="GithubAction"><p>此时需要为<code>Github</code>生成一对公私密钥，<a href="https://www.cnblogs.com/yuqiliu/p/12551258.html">参考这里</a>，点击添加之后，<code>key</code>为<code>ACCESS_TOKEN</code>，值就是生成的私钥</p></li><li><h6 id="设置-Deploy-keys"><a href="#设置-Deploy-keys" class="headerlink" title="设置 Deploy keys"></a>设置 Deploy keys</h6><ol><li><p>打开仓库<code>&lt;username&gt;.github.io</code>，打开<code>setting</code>，选择<code>Deploy keys</code>添加，<code>key</code>为<code>ACTIONS_DEPLOY_KEY</code>,值就是刚才生成的公钥，如下：</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/02.png" class="" title="GithubAction"><p>注：如果是在同一个仓库的不同分支则可以使用<code>Github Personal Token</code>，因为这是在不同仓库所以只能使用公私密钥</p></li></ol></li><li><h6 id="添加Github-Action脚本"><a href="#添加Github-Action脚本" class="headerlink" title="添加Github Action脚本"></a>添加<code>Github Action</code>脚本</h6><p>最后，就是添加<code>GithubAction</code>脚本在<code>blog</code>仓库当中了，打开<code>blog</code>仓库，点击到<code>Action</code>，新建<code>Action</code>脚本</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/03.png" class="" title="GithubAction"><p>脚本的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">name: Github Pages</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main # main 分支 push 行为时就触发这个 action</span><br><span class="line">  pull_request:</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    concurrency:</span><br><span class="line">      group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      </span><br><span class="line">      - name: Setup Node</span><br><span class="line">        uses: actions/setup-node@v2</span><br><span class="line">        with:</span><br><span class="line">          node-version: &#x27;16&#x27;</span><br><span class="line">          </span><br><span class="line">      - name: Cache dependencies</span><br><span class="line">        uses: actions/cache@v2</span><br><span class="line">        with:</span><br><span class="line">          path: ~/.npm</span><br><span class="line">          key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="line">      - run: npm ci</span><br><span class="line">      - run: npm run build</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: theme-keep/hexo-deploy-github-pages-action@master </span><br><span class="line">        env:</span><br><span class="line">          PERSONAL_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line"></span><br><span class="line">           # The repository the action should deploy to.</span><br><span class="line">          PUBLISH_REPOSITORY: bad2cat/bad2cat.github.io //这就是push 到博客仓库</span><br><span class="line"></span><br><span class="line">          # The branch the action should deploy to.</span><br><span class="line">          BRANCH: main   //push 到那个分支</span><br></pre></td></tr></table></figure></li><li><p>重新部署</p><p>现在到本地的博客根目录下，新建一个博客，然后直接将博客源码推送到<code>blog</code>仓库，然后就会触发这个脚本了，这个脚本的作用就是把博客的内容部署到<code>&lt;username&gt;.github.io</code>仓库下面，等一会刷新页面就可以看到部署的结果了</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo new post &amp;#x27;Fisrt Blog&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客（4）- 域名解析</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/</id>
    <published>2022-03-17T10:35:53.000Z</published>
    <updated>2022-06-17T07:48:55.129Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的<code>https://&lt;username&gt;.github.io</code>，这个域名收到<code>Github</code>的限制，所以更换一个自定义的域名</p><span id="more"></span><h5 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h5><h5 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h5><p>如果已经有闲置的域名就不需要在购买了；找到阿里云或者腾讯云的官网（在这使用的是阿里云的官网），<a href="https://wanwang.aliyun.com/">登入阿里云</a>，找到域名注册</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/06.png" class="" title="域名解析"><p>进入之后，输入一个域名，查看是否已经被注册了；（.com的域名有点贵，所以选了一个.com.cn的域名），首年是29，续费是每年39；当然也可以买好几年的</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/07.png" class="" title="域名解析"><p>然后加入域名清单，到域名清单进行购买；跳转之后到了如下的下面，选择所有者类型为个人，然后点击创建信息模板，如果之前有则就不用再创建了；现在购买域名都需要实名认证，不过这个认证时间很快，差不多半小时就好了；然后点击购买就好了</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/08.png" class="" title="域名解析"><h5 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2. 域名解析"></a>2. 域名解析</h5><p>买完域名之后，进入阿里云控制台；然后在你的域名下面添加两条记录</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/13.png" class="" title="域名解析"><p>这有两种记录类型：</p><ul><li>A：表示解析到一个 IP 地址，这个 IP 地址可以通过<code>ping </code><username>.github.io&#96;获取到</li><li>CNAME：表示将购买的这个域名解析到部署博客的那个<code>&lt;username&gt;.github.io</code>这个域名，这是为了防止<code>&lt;username&gt;.github.io</code> <code>的IP</code>变动</li></ul><ol start="3"><li><h5 id="添加-CNAME-文件"><a href="#添加-CNAME-文件" class="headerlink" title="添加 CNAME 文件"></a>添加 CNAME 文件</h5><p>打开本地博客的根目录，在<code>source</code>目录下面，添加<code>CNAME</code>文件（不带任何后缀），打开该文件将刚才创建的购买的域名写入</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/10.png" class="" title="域名解析"></li><li><p>执行命令将博客部署到<code>github</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>在 Github 配置CNAME</p><p>打开<code>github</code>仓库<code>&lt;username&gt;.github.io</code>，可以看到在根目录下有一个<code>CNAME</code>文件；</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/11.png" class="" title="域名解析"><p>接下来，在当前项目的<code>Setting</code>中打开<code>Pages</code>页面，然后看域名是否保存，如果没有保存，点击保存即可</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/12.png" class="" title="域名解析"><p>这样就可以通过自定义的域名来访问部署的博客了</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的&lt;code&gt;https://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;，这个域名收到&lt;code&gt;Github&lt;/code&gt;的限制，所以更换一个自定义的域名&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客(3) - 更换博客主题</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/</id>
    <published>2022-03-17T10:33:50.000Z</published>
    <updated>2022-06-17T07:48:55.129Z</updated>
    
    <content type="html"><![CDATA[<p>现在已经通过 <code>Hexo</code>搭建好了个人博客，并且发布到了<code>Github</code>上，可以通过<code>https://&lt;username&gt;.github.io</code>在公网中访问到了，解析来就是对博客进行一些优化。</p><span id="more"></span><h4 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h4><p><code>Hexo</code>默认的博客主题就是<code>Landscape</code>,如下图所示：</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/01.png" class="" title="Change Theme"><p>下面是<code>Hexo</code>排名前十的主题，你可以任意挑选一个进行替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hexo.voxel.site/</span><br></pre></td></tr></table></figure><h5 id="替换主题的步骤"><a href="#替换主题的步骤" class="headerlink" title="替换主题的步骤"></a>替换主题的步骤</h5><ol><li><p>首先到这个主题网站，点击进入到一个你选择的主题网站的<code>Github</code>中，当前选的是<code>next</code>主题，如下所示</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/02.png" class="" title="Change Theme"></li><li><p>下载主题</p><p>进入到博客的根目录下面，打开<code>git bash</code>界面，然后输入下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li><li><p>更换主题</p><p>现在已经将<code>next</code>主题下载到了本地，进入到根目录下的<code>themes</code>目录当中，就可以看到刚才下载的<code>next</code>主题；现在返回到上一层目录，然后打开<code>_config.yml</code>配置文件，在文件中找到<code>theme</code>配置项，更换为<code>next</code></p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/03.png" class="" title="Change Theme"></li><li><p>配置主题</p><p><code>next</code>有四种风格的主题，分别是：Muse，Mist，Pisces，Gemini；对应的样式就是如下的四种：</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/04.png" class="" title="Change Theme"><p>现在进入到<code>Blog/themes/next</code>目录下面，打开该目录下的<code>_config.yml</code>配置文件，然后找到配置项<code>scheme</code>,然后选择一个填入：</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/05.png" class="" title="Change Theme"><p>接下来就是保存推出</p></li><li><p>部署新主题</p><p>完成上面的操作后，执行如下的命令，将更改部署到<code>Github</code>上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时你在重新在浏览器输入<code>https://&lt;username&gt;.github.io</code>就可以看到新的主题已经更换成功了</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在已经通过 &lt;code&gt;Hexo&lt;/code&gt;搭建好了个人博客，并且发布到了&lt;code&gt;Github&lt;/code&gt;上，可以通过&lt;code&gt;https://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;在公网中访问到了，解析来就是对博客进行一些优化。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客（2）- 部署Hexo到Github pages</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/</id>
    <published>2022-03-16T07:01:54.000Z</published>
    <updated>2022-06-17T07:48:55.133Z</updated>
    
    <content type="html"><![CDATA[<p>完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 <code>Hexo</code>部署到<code>Github Pages</code>上。</p><span id="more"></span><h4 id="将-Hexo-部署到-GitHub-Pages"><a href="#将-Hexo-部署到-GitHub-Pages" class="headerlink" title="将 Hexo 部署到 GitHub Pages"></a>将 Hexo 部署到 GitHub Pages</h4><h6 id="GithubPages-说明"><a href="#GithubPages-说明" class="headerlink" title="GithubPages 说明"></a>GithubPages 说明</h6><p><code>GitHub Pages</code>就是一个免费的静态网站托管和发布平台，提供了两种托管的方式：</p><ul><li>通过 <code>Github</code>个人或者企业账号托管，这种情况下每个<code>Github</code>账号只能托管一个，并且<code>Repository</code>的名称必须为<code>username.github.io</code></li><li>通过<code>project</code>托管，这样每个<code>project</code>都可以托管一个静态网站，在这种情况下，默认托管在<code>gh-pages</code>分支下面</li></ul><p>具体可以参考<a href="https://pages.github.com/">Github pages官网</a>，当然使用<code>github pages</code>也会有一些限制，比如：</p><ul><li>发布的<code>Git Pages</code>站点不超过<code>1GB</code></li><li>每月带宽限制为<code>100GB</code>或<code>100,000</code>次请求</li><li>每小时限制构建次数不超过<code>10</code>次</li></ul><p>我选择使用<code>Github</code>个人账号托管博客，下面就是详细的将本地<code>Hexo</code>部署到 <code>GitHub Pages</code>的步骤</p><h6 id="1-在-Github创建仓"><a href="#1-在-Github创建仓" class="headerlink" title="1. 在 Github创建仓"></a>1. 在 <code>Github</code>创建仓</h6><p>登录到 <a href="https://github.com/">Github</a>，创建仓库</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/01.png" class="" title="Github创建仓库"><p>这个仓库必须创建为<code>public</code>的，仓库的名称就是<code>&lt;username&gt;.github.io</code>，<code>username</code>就是你<code>Github</code>的账号</p><h6 id="2-更改-Hexo-配置"><a href="#2-更改-Hexo-配置" class="headerlink" title="2. 更改 Hexo 配置"></a>2. 更改 Hexo 配置</h6><p>现在进入<code>hexo</code>博客的根目录，打开根目录下的配置文件<code>_config.yml</code></p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/02.png" class="" title="更改配置"><p>打开之后，滑倒文件底部，找到<code>deploy</code>属性，这一块的内容更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:  #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>更改之后的结果如下所示：</p><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/03.png" class="" title="更改配置"><h6 id="3-发布到GithubPages"><a href="#3-发布到GithubPages" class="headerlink" title="3. 发布到GithubPages"></a>3. 发布到<code>GithubPages</code></h6><p>完成上面的操作之后，在根目录打开<code>git bash</code>，安装部署插件命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装完成之后，输入一下三条命令进行部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>完成之后，就可以发现在<code>&lt;username&gt;.github.io</code>仓库中已经有内容了，说明<code>hexo</code>博客已经成功的部署到<code>github</code>上了，接下来在浏览器中输入<code>https://&lt;username&gt;.github.io</code>，就可以看到刚才部署的博客了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 &lt;code&gt;Hexo&lt;/code&gt;部署到&lt;code&gt;Github Pages&lt;/code&gt;上。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
