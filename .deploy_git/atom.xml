<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bad2cat</title>
  
  
  <link href="https://xinwazi.com/atom.xml" rel="self"/>
  
  <link href="https://xinwazi.com/"/>
  <updated>2022-04-06T05:26:29.670Z</updated>
  <id>https://xinwazi.com/</id>
  
  <author>
    <name>Adx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/</id>
    <published>2022-04-06T05:21:05.000Z</published>
    <updated>2022-04-06T05:26:29.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种创建者模式，其在父类提供了一个创建对象的方法，由具体的子类来决定实例化对象的类型</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在本地有一个快递公司，使用卡车进行货物的运输; 随着公司的壮大，现在需要支持航空运输和轮船运输; 但是，之前的代码都是关于 <code>Truck</code>类的，在 <code>Truck</code>类中<br>有一个方法<code>Delivery()</code>,之前客户端就是创建一个<code>Truck</code>类，然后调用<code>Delivery()</code>方法就完成了运输;</p><p>公司的业务扩张，现在需要支持航空运输和轮船运输; 那要如何将这两种运输的方式添加进来呢？</p><p>以前的客户端直接创建<code>Truck</code>类，然后调用其<code>Delivery</code>方法就完成货物的运输了; 如果现在也分别添加<code>Air</code>类和<code>Ship</code>类的话，那么客户端代码就会变得复杂了。<br>首先，需要知道使用那种运输方式，然后再创建相应的对象; 这样的话，客户端代码和这些实体类就紧紧的耦合在一起了，这些类对象的任何改动，或者是有新的运输方式的加入都需要更改客户端的代码，并且客户端的代码会变得越来越难以维护</p><h3 id="简单方案"><a href="#简单方案" class="headerlink" title="简单方案"></a>简单方案</h3><p>为了将客户端代码和具体的对象创建代码隔离开来，此处就需要一个接口类型<code>Transport</code>，在接口类型中声明一个<code>Delivery</code>方法; 然后让不同的运输类实现这个方法即可，这样对于客户端而言只需要传入<br>具体的运输方式，就可以创建指定的类对象了</p><p><img src="/./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/factory_simple.png" alt="factory_simple"></p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type TransportSimple interface &#123;</span><br><span class="line">Delivery() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CreateTransport(typ string) TransportSimple &#123;</span><br><span class="line">switch typ &#123;</span><br><span class="line">case &quot;truck&quot;:</span><br><span class="line">return &amp;Truck&#123;&#125;</span><br><span class="line">case &quot;airPlane&quot;:</span><br><span class="line">return &amp;AirPlane&#123;&#125;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Truck struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (t *Truck) Delivery() string &#123;</span><br><span class="line">return fmt.Sprintf(&quot;use truck delivery...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AirPlane struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (a *AirPlane) Delivery() string &#123;</span><br><span class="line">return fmt.Sprintf(&quot;use airplane delivery...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端代码</span><br><span class="line">func main() &#123;</span><br><span class="line">t := CreateTransport(&quot;truck&quot;)</span><br><span class="line">t.Delivery()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的方案已经能够很好的解决运输方式的不断更新了;但是现在公司业务越来越复杂了，比如: 在<code>Delivery</code>之前需要先对货品进行分类，然后放到不同的仓库当中，等到运输工具空闲时，再去取货运输;<br>如果是这样的话，这种简单的方案就不能够应对了，因为这不仅涉及到了运输，还有其他的类;比如：store,category 等等;这时如果还用这种方式的话，客户端的代码就又会变得很复杂和庞大了，所以就需要更加复杂的一个解决方案了</p><h3 id="复杂方案"><a href="#复杂方案" class="headerlink" title="复杂方案"></a>复杂方案</h3><p>为了能够解决公司业务的不断膨胀，这时就需要一个工厂接口了;在这个<code>Factory</code>接口中，不单只声明<code>CreateTransport()</code>方法，而且会有其他的操作了;此时的一个工厂就是一条生产线，包括：分类，存储，运输等操作了</p><p>然后，通过具体的<code>Creator</code>来实现具体的一条生产线; 客户端只需要创建一个<code>Factory</code>的实例就可以对货物进行分类，存储，运输等功能了;下面是类图示例：</p><p><img src="/./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/fac_complex.png" alt="factory_complex"></p><p>代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Factory interface &#123;</span><br><span class="line">CreateTransport() TransportSimple</span><br><span class="line">CreateStore() Store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CreatorA struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorA) CreateTransport() TransportSimple &#123;</span><br><span class="line">return &amp;Truck&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorA) CreateStore() Store &#123;</span><br><span class="line">return &amp;ColdStore&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CreatorB struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorB) CreateTransport() TransportSimple &#123;</span><br><span class="line">return &amp;AirPlane&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CreatorB) CreateStore() Store &#123;</span><br><span class="line">return &amp;HotStore&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CreateFactory(typ string) Factory &#123;</span><br><span class="line">switch typ &#123;</span><br><span class="line">case &quot;coldWithTruck&quot;:</span><br><span class="line">return &amp;CreatorA&#123;&#125;</span><br><span class="line">case &quot;hotWithAirPlane&quot;:</span><br><span class="line">return &amp;CreatorB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就能够应对公司业务的不断变化了; 可在 <a href="https://github.com/bad2cat/programming-essence/tree/main/designPattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">Github 中查可完成代码示例</a></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p> 你可以避免创建者和具体产品之间的紧密耦合。<br> 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。<br> 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;工厂模式是一种创建者模式，其在父类提供了一个创建对象的方法，由具体的子类来决定实例化对象的类型&lt;/p&gt;
&lt;h3 id=&quot;问题</summary>
      
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="design pattern" scheme="https://xinwazi.com/tags/design-pattern/"/>
    
    <category term="原型模式" scheme="https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 — 原型模式</title>
    <link href="https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-0b54b6ca657c/"/>
    <id>https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-0b54b6ca657c/</id>
    <published>2022-03-31T10:35:53.000Z</published>
    <updated>2022-03-31T01:43:25.475Z</updated>
    
    <content type="html"><![CDATA[<p>原型j就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人</p><span id="more"></span><h4 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h4><p>原型模式是一种创建型设计模式，它能够帮助你克隆指定的对象，并且无需和对象所属的类耦合，下面通过具体的问题来说明该设计模式的应用场景</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>假如现在有一个对象<code>User</code>，要复制和这个<code>User</code>完全一样的对象要怎么做呢？首先，需要新建一个同类对象，然后将<code>User</code>对象的所有成员变量复制到新对象就好了，但现在有两个问题：</p><ol><li><p>如果有组合类型，那就需要遍历组合类型的成员变量来完成复制；如果变量是私有变量，那么只能再调用获取私有变量的方法才能够实现私有变量的复制；</p><p>按照这种方式进行复制的话，这段代码就和对象所属的类产生的紧密的耦合；原对象所属的类发生的任何变化，都要在此处进行相应的更改；如果这种复制代码的操作很多的话，代码就会变的很难维护了</p></li><li><p>假如<code>User</code>是某个对象所实现的接口类型，就是指在某个方法中参数为接口而传入的具体对象的时候，方法中你拿到的是接口的类型，而不知道对象的具体类型，这种情况下要怎么实现复制呢？</p></li></ol><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>上面的问题会在代码中引入对象所属的类，导致两者产生了紧密的耦合；原型设计模式就是将克隆的过程委派给了被克隆的实际对象，这样只需要调用该对象的克隆方法就能够实现复制，而不需要和对象所属的类耦合在一起</p><p>首先，原型设计模式为所有支持克隆的对象声明了一个通用的接口，接口中通常只有一个 <code>Clone()</code>的方法；然后，实体类实现该接口，在该方法中完成对象的复制操作；最后客户端调用的时候只需要调用该对象的<code>Clone()</code>方法就能够获取到一个和该对象相同的一个对象</p><p>所有的类对<code>Clone()</code>方法的实现都很类似；该方法首先就是创建该类的一个对象，然后将原对象的所有成员变量赋值给新的对象就好了，如果有组合类型，那么调用组合类型的<code>Clone()</code>方法就好了；按照这种方式就可以实现对私有变量的复制了</p><p><img src="/./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/01.png" alt="01"></p><p>支持克隆的对象就是原型对象，当你的对象有几十种成员变量和几十种组合类型时，对其进行克隆甚至能够代替子类的构造；比如：创建一系列不同类型的对象用不同的方式进行配置，如果所需对象和预先配置的对象相同，那么就可以使用<code>Clone()</code>方法进行构造</p><h4 id="原型设计模式代码示例"><a href="#原型设计模式代码示例" class="headerlink" title="原型设计模式代码示例"></a>原型设计模式代码示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Prototype <span class="keyword">interface</span> &#123;</span><br><span class="line">Clone() Prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Color <span class="type">string</span></span><br><span class="line">Age   <span class="type">int</span></span><br><span class="line">Kind  <span class="type">string</span></span><br><span class="line">which <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Clone() Prototype &#123;</span><br><span class="line">newCar := &amp;Car&#123;</span><br><span class="line">Name:  c.Name,</span><br><span class="line">Color: c.Color,</span><br><span class="line">Age:   c.Age,</span><br><span class="line">Kind:  c.Kind,</span><br><span class="line">which: c.which,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newCar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Car&#123;</span><br><span class="line">Name:  <span class="string">&quot;BB&quot;</span>,</span><br><span class="line">Color: <span class="string">&quot;White&quot;</span>,</span><br><span class="line">Age:   <span class="number">1</span>,</span><br><span class="line">Kind:  <span class="string">&quot;BA&quot;</span>,</span><br><span class="line">which: <span class="string">&quot;Me&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&amp;c)</span><br><span class="line">cc := c.Clone()</span><br><span class="line">fmt.Println(reflect.TypeOf(cc))</span><br><span class="line">fmt.Println(cc)</span><br><span class="line">fmt.Println(&amp;cc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原型注册表"><a href="#原型注册表" class="headerlink" title="原型注册表"></a>原型注册表</h4><p>原型注册表就是将所有的原型对象存储起来，然后提供一种访问原型对象的方法；比如：可以使用<code>HashMap</code>作为存储，然后将对象的名称作为<code>key</code>，对象实例作为值存储起来；使用的时候通过对象的名称就可以获取到原型对象了</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><h6 id="独立于当前代码"><a href="#独立于当前代码" class="headerlink" title="独立于当前代码"></a>独立于当前代码</h6><p>假如当前代码中需要复制一些对象，同时又希望代码能够独立于这些对象所属的类，则就可以使用原型设计模式；</p><p>原型设计模式提供了一个通用的接口，客户端通过使用这一个通用的接口来完成与克隆对象的交互，使得客户端代码与其克隆对象的类独立开</p><h6 id="初始化子类"><a href="#初始化子类" class="headerlink" title="初始化子类"></a>初始化子类</h6><p>如果子类的区别仅在于其对象的初始化方式，那就可以使用该类来减少子类的数量。因为别人创建这些子类的目的就是为了创建特定类型的对象；在原型模式中，可以使用一系列预生成的，各种类型的对象作为原型；客户端就不需要对子类进行初始化了，只需要找到合适的原型进行克隆就好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原型j就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="design pattern" scheme="https://xinwazi.com/tags/design-pattern/"/>
    
    <category term="原型模式" scheme="https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客(5) - 集成GithubAction</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/</id>
    <published>2022-03-17T10:55:35.000Z</published>
    <updated>2022-03-30T08:37:20.863Z</updated>
    
    <content type="html"><![CDATA[<p>这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &#x27;Fisrt Blog&#x27;</span><br></pre></td></tr></table></figure><p>执行完命令之后就会在<code>Blog/source/_posts</code>下面生成一个<code>md</code>文档了，然后在该文档中写入想发表的内容之后保存；同样的执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后就可以发布博客到<code>Github</code>了，通过之前购买的域名刷新就可以看到发表的博客了；如果每次都这样写博客会很难受，并且如果更换了电脑，需要重新再打造之前的环境了。那如何解决这个问题呢？</p><span id="more"></span><h4 id="Hexo-持续集成GithubAction"><a href="#Hexo-持续集成GithubAction" class="headerlink" title="Hexo 持续集成GithubAction"></a>Hexo 持续集成<code>GithubAction</code></h4><p>为了能够在各个地方都很容易的发表博客，那就需要实现<code>Hexo</code>持续集成；现在有两种集成的方式：</p><h5 id="持续集成-Travis-CI"><a href="#持续集成-Travis-CI" class="headerlink" title="持续集成 Travis CI"></a>持续集成 <code>Travis CI</code></h5><p>这种方式可以参考，Hexo <a href="https://hexo.io/zh-cn/docs/github-pages">官方文档</a></p><h5 id="持续集成-Github-Action"><a href="#持续集成-Github-Action" class="headerlink" title="持续集成 Github Action"></a>持续集成 <code>Github Action</code></h5><p>说明：Github Action 是<code>Github</code> 的一种执行任务的脚本，将<code>hexo</code>持续集成<code>Gihub Action</code>之后，需要将本地的博客系统<code>push</code>到<code>Github</code>的一个仓库中（也可以是仓库<code>&lt;username&gt;.github.io</code>的一个分支）；之后每次写博客时，只需要将这个博客系统拉到本地，写完之后<code>push</code>上去即可，脚本<code>Github Actions</code>就会自动发布博客的更新</p><p>下面就介绍使用<code>Github Action</code>持续集成的例子</p><ol><li><h6 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h6><p>本文选择将博客系统推送的一个新的分支，所以需要创建一个新的仓库，可以将这个仓库设置为<code>private</code>，因为没必要让别人看到博客的源码，新建的仓库为<code>blog</code></p></li><li><h6 id="推送源码，设置-secret"><a href="#推送源码，设置-secret" class="headerlink" title="推送源码，设置 secret"></a>推送源码，设置 secret</h6><p>在本地的跟目录下面，打开<code>git bash</code>界面，将本地的源码推送到<code>blog</code>仓库；</p><p>注：在这里要注意一点，之前下载主题是，在主题那个文件夹会有一个<code>.git</code>隐藏文件，在你推送之前一定要把这个<code>.git</code>文件删除掉，否则推送上去之后主题就会失效</p><p>接下来，打开<code>blog</code>仓库的<code>setting</code>，添加<code>secret</code>，如下：</p><p><img src="/.%5C%E9%9B%86%E6%88%90GithubAction%5C01.png" alt="01"></p><p>此时需要为<code>Github</code>生成一对公私密钥，<a href="https://www.cnblogs.com/yuqiliu/p/12551258.html">参考这里</a>，点击添加之后，<code>key</code>为<code>ACCESS_TOKEN</code>，值就是生成的私钥</p></li><li><h6 id="设置-Deploy-keys"><a href="#设置-Deploy-keys" class="headerlink" title="设置 Deploy keys"></a>设置 Deploy keys</h6><ol><li><p>打开仓库<code>&lt;username&gt;.github.io</code>，打开<code>setting</code>，选择<code>Deploy keys</code>添加，<code>key</code>为<code>ACTIONS_DEPLOY_KEY</code>,值就是刚才生成的公钥，如下：</p><p><img src="/.%5C%E9%9B%86%E6%88%90GithubAction%5C02.png" alt="02"></p><p>注：如果是在同一个仓库的不同分支则可以使用<code>Github Personal Token</code>，因为这是在不同仓库所以只能使用公私密钥</p></li></ol></li><li><h6 id="添加Github-Action脚本"><a href="#添加Github-Action脚本" class="headerlink" title="添加Github Action脚本"></a>添加<code>Github Action</code>脚本</h6><p>最后，就是添加<code>GithubAction</code>脚本在<code>blog</code>仓库当中了，打开<code>blog</code>仓库，点击到<code>Action</code>，新建<code>Action</code>脚本</p><p><img src="/.%5C%E9%9B%86%E6%88%90GithubAction%5C03.png" alt="03"></p><p>脚本的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">name: Github Pages</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main # main 分支 push 行为时就触发这个 action</span><br><span class="line">  pull_request:</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    concurrency:</span><br><span class="line">      group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      </span><br><span class="line">      - name: Setup Node</span><br><span class="line">        uses: actions/setup-node@v2</span><br><span class="line">        with:</span><br><span class="line">          node-version: &#x27;16&#x27;</span><br><span class="line">          </span><br><span class="line">      - name: Cache dependencies</span><br><span class="line">        uses: actions/cache@v2</span><br><span class="line">        with:</span><br><span class="line">          path: ~/.npm</span><br><span class="line">          key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="line">      - run: npm ci</span><br><span class="line">      - run: npm run build</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: theme-keep/hexo-deploy-github-pages-action@master </span><br><span class="line">        env:</span><br><span class="line">          PERSONAL_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line"></span><br><span class="line">           # The repository the action should deploy to.</span><br><span class="line">          PUBLISH_REPOSITORY: bad2cat/bad2cat.github.io //这就是push 到博客仓库</span><br><span class="line"></span><br><span class="line">          # The branch the action should deploy to.</span><br><span class="line">          BRANCH: main   //push 到那个分支</span><br></pre></td></tr></table></figure></li><li><p>重新部署</p><p>现在到本地的博客根目录下，新建一个博客，然后直接将博客源码推送到<code>blog</code>仓库，然后就会触发这个脚本了，这个脚本的作用就是把博客的内容部署到<code>&lt;username&gt;.github.io</code>仓库下面，等一会刷新页面就可以看到部署的结果了</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo new post &amp;#x27;Fisrt Blog&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行完命令之后就会在&lt;code&gt;Blog/source/_posts&lt;/code&gt;下面生成一个&lt;code&gt;md&lt;/code&gt;文档了，然后在该文档中写入想发表的内容之后保存；同样的执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后就可以发布博客到&lt;code&gt;Github&lt;/code&gt;了，通过之前购买的域名刷新就可以看到发表的博客了；如果每次都这样写博客会很难受，并且如果更换了电脑，需要重新再打造之前的环境了。那如何解决这个问题呢？&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客（4）- 域名解析</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/</id>
    <published>2022-03-17T10:35:53.000Z</published>
    <updated>2022-03-30T08:37:20.703Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的<code>https://&lt;username&gt;.github.io</code>，这个域名收到<code>Github</code>的限制，所以更换一个自定义的域名</p><span id="more"></span><h5 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h5><h5 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h5><p>如果已经有闲置的域名就不需要在购买了；找到阿里云或者腾讯云的官网（在这使用的是阿里云的官网），<a href="https://wanwang.aliyun.com/">登入阿里云</a>，找到域名注册</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C06.png" alt="06"></p><p>进入之后，输入一个域名，查看是否已经被注册了；（.com的域名有点贵，所以选了一个.com.cn的域名），首年是29，续费是每年39；当然也可以买好几年的</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C07.png" alt="07"></p><p>然后加入域名清单，到域名清单进行购买；跳转之后到了如下的下面，选择所有者类型为个人，然后点击创建信息模板，如果之前有则就不用再创建了；现在购买域名都需要实名认证，不过这个认证时间很快，差不多半小时就好了；然后点击购买就好了</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C08.png" alt="08"></p><h5 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2. 域名解析"></a>2. 域名解析</h5><p>买完域名之后，进入阿里云控制台；然后在你的域名下面添加两条记录</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C13.png" alt="13"></p><p>这有两种记录类型：</p><ul><li>A：表示解析到一个 IP 地址，这个 IP 地址可以通过<code>ping </code><username>.github.io&#96;获取到</li><li>CNAME：表示将购买的这个域名解析到部署博客的那个<code>&lt;username&gt;.github.io</code>这个域名，这是为了防止<code>&lt;username&gt;.github.io</code> <code>的IP</code>变动</li></ul><ol start="3"><li><h5 id="添加-CNAME-文件"><a href="#添加-CNAME-文件" class="headerlink" title="添加 CNAME 文件"></a>添加 CNAME 文件</h5><p>打开本地博客的根目录，在<code>source</code>目录下面，添加<code>CNAME</code>文件（不带任何后缀），打开该文件将刚才创建的购买的域名写入</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C10.png" alt="10"></p></li><li><p>执行命令将博客部署到<code>github</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>在 Github 配置CNAME</p><p>打开<code>github</code>仓库<code>&lt;username&gt;.github.io</code>，可以看到在根目录下有一个<code>CNAME</code>文件；</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C11.png" alt="11"></p><p>接下来，在当前项目的<code>Setting</code>中打开<code>Pages</code>页面，然后看域名是否保存，如果没有保存，点击保存即可</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C12.png" alt="12"></p></li></ol><p>这样就可以通过自定义的域名来访问部署的博客了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的&lt;code&gt;https://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;，这个域名收到&lt;code&gt;Github&lt;/code&gt;的限制，所以更换一个自定义的域名&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客(3) - 更换博客主题</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/</id>
    <published>2022-03-17T10:33:50.000Z</published>
    <updated>2022-03-30T08:37:20.706Z</updated>
    
    <content type="html"><![CDATA[<p>现在已经通过 <code>Hexo</code>搭建好了个人博客，并且发布到了<code>Github</code>上，可以通过<code>https://&lt;username&gt;.github.io</code>在公网中访问到了，解析来就是对博客进行一些优化。</p><span id="more"></span><h4 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h4><p><code>Hexo</code>默认的博客主题就是<code>Landscape</code>,如下图所示：</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C01.png" alt="01"></p><p>下面是<code>Hexo</code>排名前十的主题，你可以任意挑选一个进行替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hexo.voxel.site/</span><br></pre></td></tr></table></figure><h5 id="替换主题的步骤"><a href="#替换主题的步骤" class="headerlink" title="替换主题的步骤"></a>替换主题的步骤</h5><ol><li><p>首先到这个主题网站，点击进入到一个你选择的主题网站的<code>Github</code>中，当前选的是<code>next</code>主题，如下所示</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C02.png" alt="02"></p></li><li><p>下载主题</p><p>进入到博客的根目录下面，打开<code>git bash</code>界面，然后输入下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li><li><p>更换主题</p><p>现在已经将<code>next</code>主题下载到了本地，进入到根目录下的<code>themes</code>目录当中，就可以看到刚才下载的<code>next</code>主题；现在返回到上一层目录，然后打开<code>_config.yml</code>配置文件，在文件中找到<code>theme</code>配置项，更换为<code>next</code></p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C03.png" alt="03"></p></li><li><p>配置主题</p><p><code>next</code>有四种风格的主题，分别是：Muse，Mist，Pisces，Gemini；对应的样式就是如下的四种：</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C04.png" alt="04"></p><p>现在进入到<code>Blog/themes/next</code>目录下面，打开该目录下的<code>_config.yml</code>配置文件，然后找到配置项<code>scheme</code>,然后选择一个填入：</p><p><img src="/.%5C%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%5C05.png" alt="05"></p><p>接下来就是保存推出</p></li><li><p>部署新主题</p><p>完成上面的操作后，执行如下的命令，将更改部署到<code>Github</code>上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时你在重新在浏览器输入<code>https://&lt;username&gt;.github.io</code>就可以看到新的主题已经更换成功了</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在已经通过 &lt;code&gt;Hexo&lt;/code&gt;搭建好了个人博客，并且发布到了&lt;code&gt;Github&lt;/code&gt;上，可以通过&lt;code&gt;https://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;在公网中访问到了，解析来就是对博客进行一些优化。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客（2）- 部署Hexo到Github pages</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/</id>
    <published>2022-03-16T07:01:54.000Z</published>
    <updated>2022-03-31T02:52:55.478Z</updated>
    
    <content type="html"><![CDATA[<p>完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 <code>Hexo</code>部署到<code>Github Pages</code>上。</p><span id="more"></span><h4 id="将-Hexo-部署到-GitHub-Pages"><a href="#将-Hexo-部署到-GitHub-Pages" class="headerlink" title="将 Hexo 部署到 GitHub Pages"></a>将 Hexo 部署到 GitHub Pages</h4><h6 id="GithubPages-说明"><a href="#GithubPages-说明" class="headerlink" title="GithubPages 说明"></a>GithubPages 说明</h6><p><code>GitHub Pages</code>就是一个免费的静态网站托管和发布平台，提供了两种托管的方式：</p><ul><li>通过 <code>Github</code>个人或者企业账号托管，这种情况下每个<code>Github</code>账号只能托管一个，并且<code>Repository</code>的名称必须为<code>username.github.io</code></li><li>通过<code>project</code>托管，这样每个<code>project</code>都可以托管一个静态网站，在这种情况下，默认托管在<code>gh-pages</code>分支下面</li></ul><p>具体可以参考<a href="https://pages.github.com/">Github pages官网</a>，当然使用<code>github pages</code>也会有一些限制，比如：</p><ul><li>发布的<code>Git Pages</code>站点不超过<code>1GB</code></li><li>每月带宽限制为<code>100GB</code>或<code>100,000</code>次请求</li><li>每小时限制构建次数不超过<code>10</code>次</li></ul><p>我选择使用<code>Github</code>个人账号托管博客，下面就是详细的将本地<code>Hexo</code>部署到 <code>GitHub Pages</code>的步骤</p><h6 id="1-在-Github创建仓"><a href="#1-在-Github创建仓" class="headerlink" title="1. 在 Github创建仓"></a>1. 在 <code>Github</code>创建仓</h6><p>登录到 <a href="https://github.com/">Github</a>，创建仓库</p><p><img src="/.%5C%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages%5C01.png" alt="01"></p><p>这个仓库必须创建为<code>public</code>的，仓库的名称就是<code>&lt;username&gt;.github.io</code>，<code>username</code>就是你<code>Github</code>的账号</p><h6 id="2-更改-Hexo-配置"><a href="#2-更改-Hexo-配置" class="headerlink" title="2. 更改 Hexo 配置"></a>2. 更改 Hexo 配置</h6><p>现在进入<code>hexo</code>博客的根目录，打开根目录下的配置文件<code>_config.yml</code></p><p><img src="/.%5C%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages.%5C02.png" alt="02"></p><p>打开之后，滑倒文件底部，找到<code>deploy</code>属性，这一块的内容更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:  #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>更改之后的结果如下所示：</p><p><img src="/.%5C%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages.%5C03.png" alt="03"></p><h6 id="3-发布到GithubPages"><a href="#3-发布到GithubPages" class="headerlink" title="3. 发布到GithubPages"></a>3. 发布到<code>GithubPages</code></h6><p>完成上面的操作之后，在根目录打开<code>git bash</code>，安装部署插件命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装完成之后，输入一下三条命令进行部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>完成之后，就可以发现在<code>&lt;username&gt;.github.io</code>仓库中已经有内容了，说明<code>hexo</code>博客已经成功的部署到<code>github</code>上了，接下来在浏览器中输入<code>https://&lt;username&gt;.github.io</code>，就可以看到刚才部署的博客了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 &lt;code&gt;Hexo&lt;/code&gt;部署到&lt;code&gt;Github Pages&lt;/code&gt;上。&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客（1）- 初始化博客</title>
    <link href="https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog-2d77129f8c92/"/>
    <id>https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog-2d77129f8c92/</id>
    <published>2022-03-16T07:01:51.000Z</published>
    <updated>2022-03-30T08:37:20.700Z</updated>
    
    <content type="html"><![CDATA[<p>最近想着搭建一个个人博客，然后在网上找到了几种搭建个人博客的方式：</p><h5 id="静态网站生成器"><a href="#静态网站生成器" class="headerlink" title="静态网站生成器"></a>静态网站生成器</h5><p>这种就是在终端使用<code>hexo,hugo,Jekyll</code>等工具，生成一个博客系统，然后通过<code>Github pages</code>进行展示</p><p>优点：可以自己选择博客主题，并且有很多插件实现评论、搜索、流量统计等功能</p><p>缺点：没有后台管理系统，需要自己在本地写完之后，发布到<code>github pages</code>上；当然，如果集成<code>github Actions</code>之后，每次写完只需要推送到<code>github</code>就可以了</p><span id="more"></span><h5 id="内容管理系统"><a href="#内容管理系统" class="headerlink" title="内容管理系统"></a>内容管理系统</h5><p>如：Wordpress，Ghost等，这种更多是企业级的应用，也可以搭建个人博客</p><p>这种博客是带有后台管理系统的，但是需要配置数据库、域名和服务器等，这些花费会比较大</p><h5 id="第三方平台"><a href="#第三方平台" class="headerlink" title="第三方平台"></a>第三方平台</h5><p>最简单就是使用第三方平台，如：掘金，简书等；并且会有站点的推广，当然也会受到平台的一些限制</p><h4 id="Hexo-搭建个人博客"><a href="#Hexo-搭建个人博客" class="headerlink" title="Hexo 搭建个人博客"></a>Hexo 搭建个人博客</h4><p>下面主要介绍通过<code>hexo</code>来搭建个人博客，同时添加<code>pure</code>作为该博客系统的主题，主题的样式可以看一下如下的<code>demo</code></p><p><a href="">hexo-pure 主题 demo</a></p><h5 id="搭建个人博客前提"><a href="#搭建个人博客前提" class="headerlink" title="搭建个人博客前提"></a>搭建个人博客前提</h5><ul><li><p>一个<code>Github</code>的账号，因为现在<code>Github</code>不再支持账密操作了，所以你还需要生成一个<code>Github Personal Token</code>，生成方式：</p><p><a href="">Github不支持账密操作的解决方案</a></p></li><li><p>本地安装 <code>Git</code></p><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul></li><li><p>安装 Node.js</p><p><a href="https://blog.csdn.net/antma/article/details/86104068">node.js 详细安装步骤</a></p></li></ul><h5 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h5><p>完成上面的操作之后，右键打开<code>Git Bash，</code>输入如下命令安装<code>hexo</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h5 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h5><p>通过上面的命令安装好<code>hexo</code>之后，就可以使用<code>hexo</code>的命令建站了，使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>执行完成之后，打开新建的目录，可以看到如下的目录列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  //站点配置文件</span><br><span class="line">├── package.json // npm 的依赖列表</span><br><span class="line">├── scaffolds    // 文章模板</span><br><span class="line">├── source      //这个下面就是具体的文章了</span><br><span class="line">|   ├── _drafts  //草稿箱</span><br><span class="line">|   └── _posts   // 发布的列表</span><br><span class="line">└── themes       // 当前博客支持的主题，默认只有一个 landscape</span><br></pre></td></tr></table></figure><p>此时，已经生成了一个静态的博客系统，可以通过如下的命令来访问本地搭建的博客</p><ol><li><code>hexo g</code>：生成静态文件</li><li><code>hexo d</code>：部署网站</li><li><code>hexo server</code>：在本地启动服务</li></ol><p>然后在浏览器中输入<code>http://localhost:4000/</code>就可以访问本地搭建的博客系统了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近想着搭建一个个人博客，然后在网上找到了几种搭建个人博客的方式：&lt;/p&gt;
&lt;h5 id=&quot;静态网站生成器&quot;&gt;&lt;a href=&quot;#静态网站生成器&quot; class=&quot;headerlink&quot; title=&quot;静态网站生成器&quot;&gt;&lt;/a&gt;静态网站生成器&lt;/h5&gt;&lt;p&gt;这种就是在终端使用&lt;code&gt;hexo,hugo,Jekyll&lt;/code&gt;等工具，生成一个博客系统，然后通过&lt;code&gt;Github pages&lt;/code&gt;进行展示&lt;/p&gt;
&lt;p&gt;优点：可以自己选择博客主题，并且有很多插件实现评论、搜索、流量统计等功能&lt;/p&gt;
&lt;p&gt;缺点：没有后台管理系统，需要自己在本地写完之后，发布到&lt;code&gt;github pages&lt;/code&gt;上；当然，如果集成&lt;code&gt;github Actions&lt;/code&gt;之后，每次写完只需要推送到&lt;code&gt;github&lt;/code&gt;就可以了&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://xinwazi.com/tags/hexo/"/>
    
    <category term="个人博客搭建" scheme="https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>DNS 域名解析--详解</title>
    <link href="https://xinwazi.com/%E7%BD%91%E7%BB%9C/DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-836daf7bc346/"/>
    <id>https://xinwazi.com/%E7%BD%91%E7%BB%9C/DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-836daf7bc346/</id>
    <published>2022-03-13T12:08:56.000Z</published>
    <updated>2022-03-16T05:39:01.844Z</updated>
    
    <content type="html"><![CDATA[<p>因为网络中数据的传输是通过 <code>TCP/IP</code>协议来完成的，在该协议中传输需要知道对端的 <code>IP</code>地址，然后通过 <code>IP</code>地址完成数据的传输。</p><p>那当用户在浏览器中输入域名时，这个域名是如何被转换成 <code>IP</code>地址来完成数据传输的呢？</p><span id="more"></span><p>这就是通过域名解析来完成的，域名解析这个词有点抽象，但是换个词可能就比较好理解了，比如：<code>IP</code>登记，域名指向等</p><p>就 <code>IP</code> 登记而言，这个词就表明存在这么一个登记处，如果你想你的网站被别人能够访问到，就需要到这个登记处进行登记，在你登记的时候域名就相当于你的名字，<code>IP</code>就相当于你的住址；这样其他用户就可以通过域名来访问你的网站了，不再需要记住那些难记的 <code>IP</code>地址了</p><p>上面所说的<code> IP</code> 登记处就是<code> DNS</code> 服务器了，每次当你在浏览器输入一个域名时，都会向<code> DNS</code> 请求这个域名对应的<code>IP</code>地址，找到之后再通过<code> IP</code> 完成具体的访问操作</p><h5 id="是谁帮你完成域名解析的呢"><a href="#是谁帮你完成域名解析的呢" class="headerlink" title="是谁帮你完成域名解析的呢"></a>是谁帮你完成域名解析的呢</h5><p>因为浏览器本身不具备将消息发送到网络中的功能，所以这一步就是委托操作系统来完成的</p><p>操作系统在接收到请求之后，如果是看到是<code> IP</code> 则直接发送到下一层了；如果是域名，则就把域名发给<code>DNS</code>客户端，然后由 <code>DNS</code> 客户端去连接你网络配置的 <code>DNS</code> 服务器，连接之后请求返回该域名对应的<code> IP</code>，获取到<code> IP</code> 之后再交给操作系统，然后继续完成之后的网络请求操作</p><h5 id="如果本机配置的-DNS-服务器没有找到该域名对应的-IP-怎么办呢"><a href="#如果本机配置的-DNS-服务器没有找到该域名对应的-IP-怎么办呢" class="headerlink" title="如果本机配置的 DNS 服务器没有找到该域名对应的 IP 怎么办呢"></a>如果本机配置的 DNS 服务器没有找到该域名对应的 IP 怎么办呢</h5><p>每个联网的终端，都会配置一个 <code>DNS</code>服务器，即便是你没有主动的配置，则每次上网时也会由网关自动分配（这种由网关分配的机制就是 <code>DHCP</code>）</p><p>当你在浏览器输入域名之后，OS就会到这个 <code>DNS</code> 服务器上去请求域名对应的<code>IP</code> 地址，如果请求到，则继续完成之前的请求；如果没有请求到，则就会进行分级查询了</p><h5 id="域名的层级"><a href="#域名的层级" class="headerlink" title="域名的层级"></a>域名的层级</h5><p>在了解域名的分级查询之前，先看一下域名的层级，因为就是通过域名的层级进行分级查询的；</p><p>下面是百度的域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com.</span><br></pre></td></tr></table></figure><p>通过域名解析工具，可以看到其实百度官网域名的后面会带一个<code>.</code>,这是因为所有的域名的尾部都会有一个根域名，完整的百度的域名应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com.root</span><br></pre></td></tr></table></figure><p>因为根域名<code>root</code>对所有的域名都一样的，所以平时都会省略点，就变成了<code>https://www.baidu.com.</code></p><p>根域名的下一级域名叫做”顶级域名”（top-level domain，缩写 TLD），比如像<code>.com,.net</code>这些；</p><p>再下一级的域名叫做二级域名（second-level domain，缩写 SLD），如：<code>https://www.baidu.com.</code>中的<code>.baidu</code>，这一级的域名是用户可以注册到的；</p><p>再下一级的域名就是三级域名也是主机名，如：<code>www</code>，这是用户在自己的域里为服务器配置的名称，是用户可以任意分配的</p><h5 id="分级查询"><a href="#分级查询" class="headerlink" title="分级查询"></a>分级查询</h5><p>所谓的分级查询就是当你在你配置的 DNS 服务器中找不到域名对应的 IP 之后，由当前的 DNS 服务器向根域名服务器发起的请求</p><p>首先说明一点，每一级域名都有自己的 <code>NS（Name Server）</code> 记录（记录域名服务器的记录，就是指定那些域名该有哪个 DNS 服务器来解析）</p><p>分级查询是从根域名开始，依次查找每一级域名的 NS 记录，找到查到最终的 IP 地址为止，具体查找过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 从 根域名服务器 找到顶级域名服务器的 NS 记录和 IP 地址</span><br><span class="line">2. 从 顶级域名服务器 找到二级域名服务器的 NS 记录和 IP 地址</span><br><span class="line">3. 从 二级域名服务器 找到 三级域名（主机名）的 IP 地址</span><br></pre></td></tr></table></figure><p>那在分级查询到第一步中是如何知道根域名服务器的地址的呢</p><p>这是因为根域名服务器的 NS 记录和 IP 地址一般不会变，所以通常是内置在 DNS 服务器当中的</p><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><p>如果每次都需要这么解析一遍那么访问一个网站就会变的很慢了，同时也会对根域名服务器造成压力</p><p>因此通常就会对 DNS 解析的记录进行缓存，通常有两种缓存的方式：</p><h6 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h6><p>浏览器缓存就是每次会对访问过的域名对应的 IP 缓存起来，当然这个缓存的时间也是根据不同的浏览器的厂商而定的；谷歌的一般是缓存一分钟，也可以在谷歌浏览器中输入：<code>chrome://net-internals/#dns</code>来清除缓存</p><p>OS缓存</p><p>另外一种就是操作系统对于 DNS 的缓存，每次 DNS Client 请求得到的解析记录都会有一个 TTL 值，这个就是 DNS 服务器提供的 DNS 解析结果的最长存活时间，OS 缓存的 DNS 就会参考这个时间，但是不会完全的等于这个时间；通过命令<code>ipconfig/displaydns</code>就可以查看到本机的 DNS 缓存；也可以使用命令<code>ipconfig/flushdns</code>来清除这些缓存</p><h5 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h5><p>上面介绍了 DNS 域名解析的原理，现在又有了一个新的问题：什么是 DNS 劫持？</p><p>正常情况下我们在浏览器输入请求后，OS 都会先到本机的 <code>hosts</code>文件查看是否有域名对应的 IP ，如果有则直接通过这个 IP 进行访问就可以了，如果没有，则就会到网络配置的 DNS 服务器上去获取当前域名对应的 IP 地址</p><p>但是，如果现在有一个木马程序，入侵你的电脑之后更改了你的 <code>hosts</code>文件，将你访问的百度的域名对应到一个广告网站或者是其他的恶意网站，此时你再访问<code>www.baidu.com</code>的时候出现的就不会是百度的首页了，而是修改之后的恶意网站了，这就是本地 DNS 劫持</p><p>本地 DNS 劫持就是因为病毒的入侵，所以你要安装杀毒软件，经常扫描；当然还需要开启防火墙，这样就可以防止病毒的入侵了</p><p>除了本地的 DNS 劫持外，还有就是路由器的 DNS 劫持，现在市场上的路由器的质量层级不齐，并且很多的用户买了路由器之后使用的还是默认的密码，所以很容易遭到攻击；</p><p>攻击获得管理权限之后，篡改路由器上设置的 DNS 服务器的地址，使其指向恶意的 DNS 服务器，这样当你发送请求的时候就会给你返回恶意网站的 IP地址；所以为了避免这种情况需要加强对路由器账号密码的管理，防止被恶意用户获取到路由器权限</p><p>第三种劫持就是攻击权威的 DNS 服务器，导致 DNS 服务器停止服务，还可以使用一些手段感染 DNS 缓存，给用户返回恶意的 IP 地址</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为网络中数据的传输是通过 &lt;code&gt;TCP/IP&lt;/code&gt;协议来完成的，在该协议中传输需要知道对端的 &lt;code&gt;IP&lt;/code&gt;地址，然后通过 &lt;code&gt;IP&lt;/code&gt;地址完成数据的传输。&lt;/p&gt;
&lt;p&gt;那当用户在浏览器中输入域名时，这个域名是如何被转换成 &lt;code&gt;IP&lt;/code&gt;地址来完成数据传输的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://xinwazi.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="DNS" scheme="https://xinwazi.com/tags/DNS/"/>
    
    <category term="域名解析" scheme="https://xinwazi.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
