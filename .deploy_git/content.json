{"meta":{"title":"bad2cat","subtitle":"","description":"Be a thinker!","author":"Adx","url":"https://xinwazi.com","root":"/"},"pages":[{"title":"about","date":"2022-03-02T13:48:10.000Z","updated":"2022-03-14T04:24:14.903Z","comments":true,"path":"about/index.html","permalink":"https://xinwazi.com/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-16T00:32:25.980Z","updated":"2022-03-15T08:08:14.432Z","comments":false,"path":"books/index.html","permalink":"https://xinwazi.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-23T13:35:44.000Z","updated":"2022-03-14T04:24:14.903Z","comments":false,"path":"categories/index.html","permalink":"https://xinwazi.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-15T08:08:14.432Z","updated":"2022-03-15T08:08:14.432Z","comments":true,"path":"links/index.html","permalink":"https://xinwazi.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-23T13:35:54.000Z","updated":"2022-03-14T04:24:14.903Z","comments":false,"path":"tags/index.html","permalink":"https://xinwazi.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-16T00:32:13.339Z","updated":"2022-03-15T08:08:14.432Z","comments":false,"path":"repository/index.html","permalink":"https://xinwazi.com/repository/index.html","excerpt":"","text":""},{"title":"日程表","date":"2022-02-23T13:36:26.000Z","updated":"2022-03-14T04:24:14.903Z","comments":false,"path":"schedule/index.html","permalink":"https://xinwazi.com/schedule/index.html","excerpt":"","text":""},{"title":"思想","date":"2022-03-19T03:31:13.000Z","updated":"2022-03-30T08:37:20.894Z","comments":true,"path":"思想/index.html","permalink":"https://xinwazi.com/%E6%80%9D%E6%83%B3/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-30T08:37:20.892Z","updated":"2022-03-30T08:37:20.892Z","comments":true,"path":"思想/NewWorld.html","permalink":"https://xinwazi.com/%E6%80%9D%E6%83%B3/NewWorld.html","excerpt":"","text":""}],"posts":[{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2022-04-06T05:21:05.000Z","updated":"2022-04-06T05:26:29.670Z","comments":true,"path":"设计模式/设计模式-工厂模式-9291bb2ccc7f/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/","excerpt":"","text":"工厂模式工厂模式是一种创建者模式，其在父类提供了一个创建对象的方法，由具体的子类来决定实例化对象的类型 问题在本地有一个快递公司，使用卡车进行货物的运输; 随着公司的壮大，现在需要支持航空运输和轮船运输; 但是，之前的代码都是关于 Truck类的，在 Truck类中有一个方法Delivery(),之前客户端就是创建一个Truck类，然后调用Delivery()方法就完成了运输; 公司的业务扩张，现在需要支持航空运输和轮船运输; 那要如何将这两种运输的方式添加进来呢？ 以前的客户端直接创建Truck类，然后调用其Delivery方法就完成货物的运输了; 如果现在也分别添加Air类和Ship类的话，那么客户端代码就会变得复杂了。首先，需要知道使用那种运输方式，然后再创建相应的对象; 这样的话，客户端代码和这些实体类就紧紧的耦合在一起了，这些类对象的任何改动，或者是有新的运输方式的加入都需要更改客户端的代码，并且客户端的代码会变得越来越难以维护 简单方案为了将客户端代码和具体的对象创建代码隔离开来，此处就需要一个接口类型Transport，在接口类型中声明一个Delivery方法; 然后让不同的运输类实现这个方法即可，这样对于客户端而言只需要传入具体的运输方式，就可以创建指定的类对象了 代码示例： 1234567891011121314151617181920212223242526272829303132333435import &quot;fmt&quot;type TransportSimple interface &#123; Delivery() string&#125;func CreateTransport(typ string) TransportSimple &#123; switch typ &#123; case &quot;truck&quot;: return &amp;Truck&#123;&#125; case &quot;airPlane&quot;: return &amp;AirPlane&#123;&#125; default: return nil &#125;&#125;type Truck struct&#123;&#125;func (t *Truck) Delivery() string &#123; return fmt.Sprintf(&quot;use truck delivery...&quot;)&#125;type AirPlane struct&#123;&#125;func (a *AirPlane) Delivery() string &#123; return fmt.Sprintf(&quot;use airplane delivery...&quot;)&#125;//客户端代码func main() &#123; t := CreateTransport(&quot;truck&quot;) t.Delivery()&#125; 上面的方案已经能够很好的解决运输方式的不断更新了;但是现在公司业务越来越复杂了，比如: 在Delivery之前需要先对货品进行分类，然后放到不同的仓库当中，等到运输工具空闲时，再去取货运输;如果是这样的话，这种简单的方案就不能够应对了，因为这不仅涉及到了运输，还有其他的类;比如：store,category 等等;这时如果还用这种方式的话，客户端的代码就又会变得很复杂和庞大了，所以就需要更加复杂的一个解决方案了 复杂方案为了能够解决公司业务的不断膨胀，这时就需要一个工厂接口了;在这个Factory接口中，不单只声明CreateTransport()方法，而且会有其他的操作了;此时的一个工厂就是一条生产线，包括：分类，存储，运输等操作了 然后，通过具体的Creator来实现具体的一条生产线; 客户端只需要创建一个Factory的实例就可以对货物进行分类，存储，运输等功能了;下面是类图示例： 代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637package maintype Factory interface &#123; CreateTransport() TransportSimple CreateStore() Store&#125;type CreatorA struct&#123;&#125;func (c *CreatorA) CreateTransport() TransportSimple &#123; return &amp;Truck&#123;&#125;&#125;func (c *CreatorA) CreateStore() Store &#123; return &amp;ColdStore&#123;&#125;&#125;type CreatorB struct&#123;&#125;func (c *CreatorB) CreateTransport() TransportSimple &#123; return &amp;AirPlane&#123;&#125;&#125;func (c *CreatorB) CreateStore() Store &#123; return &amp;HotStore&#123;&#125;&#125;func CreateFactory(typ string) Factory &#123; switch typ &#123; case &quot;coldWithTruck&quot;: return &amp;CreatorA&#123;&#125; case &quot;hotWithAirPlane&quot;: return &amp;CreatorB&#123;&#125; &#125; return nil&#125; 这样就能够应对公司业务的不断变化了; 可在 Github 中查可完成代码示例 优缺点优点 你可以避免创建者和具体产品之间的紧密耦合。 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。 缺点应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://xinwazi.com/tags/design-pattern/"},{"name":"原型模式","slug":"原型模式","permalink":"https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 — 原型模式","slug":"设计模式-原型模式","date":"2022-03-31T10:35:53.000Z","updated":"2022-03-31T01:43:25.475Z","comments":true,"path":"设计模式/设计模式-原型模式-0b54b6ca657c/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-0b54b6ca657c/","excerpt":"原型j就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人","text":"原型j就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人 原型设计模式原型模式是一种创建型设计模式，它能够帮助你克隆指定的对象，并且无需和对象所属的类耦合，下面通过具体的问题来说明该设计模式的应用场景 问题假如现在有一个对象User，要复制和这个User完全一样的对象要怎么做呢？首先，需要新建一个同类对象，然后将User对象的所有成员变量复制到新对象就好了，但现在有两个问题： 如果有组合类型，那就需要遍历组合类型的成员变量来完成复制；如果变量是私有变量，那么只能再调用获取私有变量的方法才能够实现私有变量的复制； 按照这种方式进行复制的话，这段代码就和对象所属的类产生的紧密的耦合；原对象所属的类发生的任何变化，都要在此处进行相应的更改；如果这种复制代码的操作很多的话，代码就会变的很难维护了 假如User是某个对象所实现的接口类型，就是指在某个方法中参数为接口而传入的具体对象的时候，方法中你拿到的是接口的类型，而不知道对象的具体类型，这种情况下要怎么实现复制呢？ 解决方法上面的问题会在代码中引入对象所属的类，导致两者产生了紧密的耦合；原型设计模式就是将克隆的过程委派给了被克隆的实际对象，这样只需要调用该对象的克隆方法就能够实现复制，而不需要和对象所属的类耦合在一起 首先，原型设计模式为所有支持克隆的对象声明了一个通用的接口，接口中通常只有一个 Clone()的方法；然后，实体类实现该接口，在该方法中完成对象的复制操作；最后客户端调用的时候只需要调用该对象的Clone()方法就能够获取到一个和该对象相同的一个对象 所有的类对Clone()方法的实现都很类似；该方法首先就是创建该类的一个对象，然后将原对象的所有成员变量赋值给新的对象就好了，如果有组合类型，那么调用组合类型的Clone()方法就好了；按照这种方式就可以实现对私有变量的复制了 支持克隆的对象就是原型对象，当你的对象有几十种成员变量和几十种组合类型时，对其进行克隆甚至能够代替子类的构造；比如：创建一系列不同类型的对象用不同的方式进行配置，如果所需对象和预先配置的对象相同，那么就可以使用Clone()方法进行构造 原型设计模式代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type Prototype interface &#123; Clone() Prototype&#125;type Car struct &#123; Name string Color string Age int Kind string which string&#125;func (c *Car) Clone() Prototype &#123; newCar := &amp;Car&#123; Name: c.Name, Color: c.Color, Age: c.Age, Kind: c.Kind, which: c.which, &#125; return newCar&#125;func main() &#123; c := &amp;Car&#123; Name: &quot;BB&quot;, Color: &quot;White&quot;, Age: 1, Kind: &quot;BA&quot;, which: &quot;Me&quot;, &#125; fmt.Println(&amp;c) cc := c.Clone() fmt.Println(reflect.TypeOf(cc)) fmt.Println(cc) fmt.Println(&amp;cc)&#125; 原型注册表原型注册表就是将所有的原型对象存储起来，然后提供一种访问原型对象的方法；比如：可以使用HashMap作为存储，然后将对象的名称作为key，对象实例作为值存储起来；使用的时候通过对象的名称就可以获取到原型对象了 适用场景独立于当前代码假如当前代码中需要复制一些对象，同时又希望代码能够独立于这些对象所属的类，则就可以使用原型设计模式； 原型设计模式提供了一个通用的接口，客户端通过使用这一个通用的接口来完成与克隆对象的交互，使得客户端代码与其克隆对象的类独立开 初始化子类如果子类的区别仅在于其对象的初始化方式，那就可以使用该类来减少子类的数量。因为别人创建这些子类的目的就是为了创建特定类型的对象；在原型模式中，可以使用一系列预生成的，各种类型的对象作为原型；客户端就不需要对子类进行初始化了，只需要找到合适的原型进行克隆就好了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://xinwazi.com/tags/design-pattern/"},{"name":"原型模式","slug":"原型模式","permalink":"https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"搭建个人博客(5) - 集成GithubAction","slug":"集成GithubAction","date":"2022-03-17T10:55:35.000Z","updated":"2022-03-30T08:37:20.863Z","comments":true,"path":"博客搭建/集成GithubAction-e7401dd28c77/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/","excerpt":"这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下： 1hexo new post &#x27;Fisrt Blog&#x27; 执行完命令之后就会在Blog/source/_posts下面生成一个md文档了，然后在该文档中写入想发表的内容之后保存；同样的执行命令： 123hexo cleanhexo ghexo d 然后就可以发布博客到Github了，通过之前购买的域名刷新就可以看到发表的博客了；如果每次都这样写博客会很难受，并且如果更换了电脑，需要重新再打造之前的环境了。那如何解决这个问题呢？","text":"这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下： 1hexo new post &#x27;Fisrt Blog&#x27; 执行完命令之后就会在Blog/source/_posts下面生成一个md文档了，然后在该文档中写入想发表的内容之后保存；同样的执行命令： 123hexo cleanhexo ghexo d 然后就可以发布博客到Github了，通过之前购买的域名刷新就可以看到发表的博客了；如果每次都这样写博客会很难受，并且如果更换了电脑，需要重新再打造之前的环境了。那如何解决这个问题呢？ Hexo 持续集成GithubAction为了能够在各个地方都很容易的发表博客，那就需要实现Hexo持续集成；现在有两种集成的方式： 持续集成 Travis CI这种方式可以参考，Hexo 官方文档 持续集成 Github Action说明：Github Action 是Github 的一种执行任务的脚本，将hexo持续集成Gihub Action之后，需要将本地的博客系统push到Github的一个仓库中（也可以是仓库&lt;username&gt;.github.io的一个分支）；之后每次写博客时，只需要将这个博客系统拉到本地，写完之后push上去即可，脚本Github Actions就会自动发布博客的更新 下面就介绍使用Github Action持续集成的例子 添加仓库本文选择将博客系统推送的一个新的分支，所以需要创建一个新的仓库，可以将这个仓库设置为private，因为没必要让别人看到博客的源码，新建的仓库为blog 推送源码，设置 secret在本地的跟目录下面，打开git bash界面，将本地的源码推送到blog仓库； 注：在这里要注意一点，之前下载主题是，在主题那个文件夹会有一个.git隐藏文件，在你推送之前一定要把这个.git文件删除掉，否则推送上去之后主题就会失效 接下来，打开blog仓库的setting，添加secret，如下： 此时需要为Github生成一对公私密钥，参考这里，点击添加之后，key为ACCESS_TOKEN，值就是生成的私钥 设置 Deploy keys 打开仓库&lt;username&gt;.github.io，打开setting，选择Deploy keys添加，key为ACTIONS_DEPLOY_KEY,值就是刚才生成的公钥，如下： 注：如果是在同一个仓库的不同分支则可以使用Github Personal Token，因为这是在不同仓库所以只能使用公私密钥 添加Github Action脚本最后，就是添加GithubAction脚本在blog仓库当中了，打开blog仓库，点击到Action，新建Action脚本 脚本的内容如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041name: Github Pageson: push: branches: - main # main 分支 push 行为时就触发这个 action pull_request:jobs: build-and-deploy: runs-on: ubuntu-latest concurrency: group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; github.ref &#125;&#125; steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2 with: node-version: &#x27;16&#x27; - name: Cache dependencies uses: actions/cache@v2 with: path: ~/.npm key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125; restore-keys: | $&#123;&#123; runner.os &#125;&#125;-node- - run: npm ci - run: npm run build - name: Deploy uses: theme-keep/hexo-deploy-github-pages-action@master env: PERSONAL_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; # The repository the action should deploy to. PUBLISH_REPOSITORY: bad2cat/bad2cat.github.io //这就是push 到博客仓库 # The branch the action should deploy to. BRANCH: main //push 到那个分支 重新部署 现在到本地的博客根目录下，新建一个博客，然后直接将博客源码推送到blog仓库，然后就会触发这个脚本了，这个脚本的作用就是把博客的内容部署到&lt;username&gt;.github.io仓库下面，等一会刷新页面就可以看到部署的结果了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客（4）- 域名解析","slug":"域名解析","date":"2022-03-17T10:35:53.000Z","updated":"2022-03-30T08:37:20.703Z","comments":true,"path":"博客搭建/域名解析-c101a3028bc7/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/","excerpt":"在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的https://&lt;username&gt;.github.io，这个域名收到Github的限制，所以更换一个自定义的域名","text":"在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的https://&lt;username&gt;.github.io，这个域名收到Github的限制，所以更换一个自定义的域名 域名解析1. 购买域名如果已经有闲置的域名就不需要在购买了；找到阿里云或者腾讯云的官网（在这使用的是阿里云的官网），登入阿里云，找到域名注册 进入之后，输入一个域名，查看是否已经被注册了；（.com的域名有点贵，所以选了一个.com.cn的域名），首年是29，续费是每年39；当然也可以买好几年的 然后加入域名清单，到域名清单进行购买；跳转之后到了如下的下面，选择所有者类型为个人，然后点击创建信息模板，如果之前有则就不用再创建了；现在购买域名都需要实名认证，不过这个认证时间很快，差不多半小时就好了；然后点击购买就好了 2. 域名解析买完域名之后，进入阿里云控制台；然后在你的域名下面添加两条记录 这有两种记录类型： A：表示解析到一个 IP 地址，这个 IP 地址可以通过ping .github.io&#96;获取到 CNAME：表示将购买的这个域名解析到部署博客的那个&lt;username&gt;.github.io这个域名，这是为了防止&lt;username&gt;.github.io 的IP变动 添加 CNAME 文件打开本地博客的根目录，在source目录下面，添加CNAME文件（不带任何后缀），打开该文件将刚才创建的购买的域名写入 执行命令将博客部署到github 123hexo cleanhexo ghexo d 在 Github 配置CNAME 打开github仓库&lt;username&gt;.github.io，可以看到在根目录下有一个CNAME文件； 接下来，在当前项目的Setting中打开Pages页面，然后看域名是否保存，如果没有保存，点击保存即可 这样就可以通过自定义的域名来访问部署的博客了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客(3) - 更换博客主题","slug":"更换博客主题","date":"2022-03-17T10:33:50.000Z","updated":"2022-03-30T08:37:20.706Z","comments":true,"path":"博客搭建/更换博客主题-41b8ba561387/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/","excerpt":"现在已经通过 Hexo搭建好了个人博客，并且发布到了Github上，可以通过https://&lt;username&gt;.github.io在公网中访问到了，解析来就是对博客进行一些优化。","text":"现在已经通过 Hexo搭建好了个人博客，并且发布到了Github上，可以通过https://&lt;username&gt;.github.io在公网中访问到了，解析来就是对博客进行一些优化。 更换博客主题Hexo默认的博客主题就是Landscape,如下图所示： 下面是Hexo排名前十的主题，你可以任意挑选一个进行替换 1https://hexo.voxel.site/ 替换主题的步骤 首先到这个主题网站，点击进入到一个你选择的主题网站的Github中，当前选的是next主题，如下所示 下载主题 进入到博客的根目录下面，打开git bash界面，然后输入下面的命令 1git clone https://github.com/theme-next/hexo-theme-next themes/next 更换主题 现在已经将next主题下载到了本地，进入到根目录下的themes目录当中，就可以看到刚才下载的next主题；现在返回到上一层目录，然后打开_config.yml配置文件，在文件中找到theme配置项，更换为next 配置主题 next有四种风格的主题，分别是：Muse，Mist，Pisces，Gemini；对应的样式就是如下的四种： 现在进入到Blog/themes/next目录下面，打开该目录下的_config.yml配置文件，然后找到配置项scheme,然后选择一个填入： 接下来就是保存推出 部署新主题 完成上面的操作后，执行如下的命令，将更改部署到Github上 123hexo cleanhexo ghexo d 此时你在重新在浏览器输入https://&lt;username&gt;.github.io就可以看到新的主题已经更换成功了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客（2）- 部署Hexo到Github pages","slug":"部署Hexo到Github-pages","date":"2022-03-16T07:01:54.000Z","updated":"2022-03-31T02:52:55.478Z","comments":true,"path":"博客搭建/部署Hexo到Github-pages-a3a757356023/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/","excerpt":"完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 Hexo部署到Github Pages上。","text":"完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 Hexo部署到Github Pages上。 将 Hexo 部署到 GitHub PagesGithubPages 说明GitHub Pages就是一个免费的静态网站托管和发布平台，提供了两种托管的方式： 通过 Github个人或者企业账号托管，这种情况下每个Github账号只能托管一个，并且Repository的名称必须为username.github.io 通过project托管，这样每个project都可以托管一个静态网站，在这种情况下，默认托管在gh-pages分支下面 具体可以参考Github pages官网，当然使用github pages也会有一些限制，比如： 发布的Git Pages站点不超过1GB 每月带宽限制为100GB或100,000次请求 每小时限制构建次数不超过10次 我选择使用Github个人账号托管博客，下面就是详细的将本地Hexo部署到 GitHub Pages的步骤 1. 在 Github创建仓登录到 Github，创建仓库 这个仓库必须创建为public的，仓库的名称就是&lt;username&gt;.github.io，username就是你Github的账号 2. 更改 Hexo 配置现在进入hexo博客的根目录，打开根目录下的配置文件_config.yml 打开之后，滑倒文件底部，找到deploy属性，这一块的内容更改为： 1234deploy: type: git repository: #你的仓库地址 branch: main 更改之后的结果如下所示： 3. 发布到GithubPages完成上面的操作之后，在根目录打开git bash，安装部署插件命令如下： 1npm install hexo-deployer-git --save 安装完成之后，输入一下三条命令进行部署 123hexo clean #清除缓存文件 db.json 和已生成的静态文件 publichexo g #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)hexo d #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写) 完成之后，就可以发现在&lt;username&gt;.github.io仓库中已经有内容了，说明hexo博客已经成功的部署到github上了，接下来在浏览器中输入https://&lt;username&gt;.github.io，就可以看到刚才部署的博客了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客（1）- 初始化博客","slug":"使用hexo搭建个人blog","date":"2022-03-16T07:01:51.000Z","updated":"2022-03-30T08:37:20.700Z","comments":true,"path":"博客搭建/使用hexo搭建个人blog-2d77129f8c92/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog-2d77129f8c92/","excerpt":"最近想着搭建一个个人博客，然后在网上找到了几种搭建个人博客的方式： 静态网站生成器这种就是在终端使用hexo,hugo,Jekyll等工具，生成一个博客系统，然后通过Github pages进行展示 优点：可以自己选择博客主题，并且有很多插件实现评论、搜索、流量统计等功能 缺点：没有后台管理系统，需要自己在本地写完之后，发布到github pages上；当然，如果集成github Actions之后，每次写完只需要推送到github就可以了","text":"最近想着搭建一个个人博客，然后在网上找到了几种搭建个人博客的方式： 静态网站生成器这种就是在终端使用hexo,hugo,Jekyll等工具，生成一个博客系统，然后通过Github pages进行展示 优点：可以自己选择博客主题，并且有很多插件实现评论、搜索、流量统计等功能 缺点：没有后台管理系统，需要自己在本地写完之后，发布到github pages上；当然，如果集成github Actions之后，每次写完只需要推送到github就可以了 内容管理系统如：Wordpress，Ghost等，这种更多是企业级的应用，也可以搭建个人博客 这种博客是带有后台管理系统的，但是需要配置数据库、域名和服务器等，这些花费会比较大 第三方平台最简单就是使用第三方平台，如：掘金，简书等；并且会有站点的推广，当然也会受到平台的一些限制 Hexo 搭建个人博客下面主要介绍通过hexo来搭建个人博客，同时添加pure作为该博客系统的主题，主题的样式可以看一下如下的demo hexo-pure 主题 demo 搭建个人博客前提 一个Github的账号，因为现在Github不再支持账密操作了，所以你还需要生成一个Github Personal Token，生成方式： Github不支持账密操作的解决方案 本地安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts 或者下载 安装程序。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装 Node.js node.js 详细安装步骤 安装 Hexo完成上面的操作之后，右键打开Git Bash，输入如下命令安装hexo： 1npm install -g hexo-cli 建站通过上面的命令安装好hexo之后，就可以使用hexo的命令建站了，使用命令 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 执行完成之后，打开新建的目录，可以看到如下的目录列表： 12345678.├── _config.yml //站点配置文件├── package.json // npm 的依赖列表├── scaffolds // 文章模板├── source //这个下面就是具体的文章了| ├── _drafts //草稿箱| └── _posts // 发布的列表└── themes // 当前博客支持的主题，默认只有一个 landscape 此时，已经生成了一个静态的博客系统，可以通过如下的命令来访问本地搭建的博客 hexo g：生成静态文件 hexo d：部署网站 hexo server：在本地启动服务 然后在浏览器中输入http://localhost:4000/就可以访问本地搭建的博客系统了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"DNS 域名解析--详解","slug":"DNS-域名解析","date":"2022-03-13T12:08:56.000Z","updated":"2022-03-16T05:39:01.844Z","comments":true,"path":"网络/DNS-域名解析-836daf7bc346/","link":"","permalink":"https://xinwazi.com/%E7%BD%91%E7%BB%9C/DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-836daf7bc346/","excerpt":"因为网络中数据的传输是通过 TCP/IP协议来完成的，在该协议中传输需要知道对端的 IP地址，然后通过 IP地址完成数据的传输。 那当用户在浏览器中输入域名时，这个域名是如何被转换成 IP地址来完成数据传输的呢？","text":"因为网络中数据的传输是通过 TCP/IP协议来完成的，在该协议中传输需要知道对端的 IP地址，然后通过 IP地址完成数据的传输。 那当用户在浏览器中输入域名时，这个域名是如何被转换成 IP地址来完成数据传输的呢？ 这就是通过域名解析来完成的，域名解析这个词有点抽象，但是换个词可能就比较好理解了，比如：IP登记，域名指向等 就 IP 登记而言，这个词就表明存在这么一个登记处，如果你想你的网站被别人能够访问到，就需要到这个登记处进行登记，在你登记的时候域名就相当于你的名字，IP就相当于你的住址；这样其他用户就可以通过域名来访问你的网站了，不再需要记住那些难记的 IP地址了 上面所说的 IP 登记处就是 DNS 服务器了，每次当你在浏览器输入一个域名时，都会向 DNS 请求这个域名对应的IP地址，找到之后再通过 IP 完成具体的访问操作 是谁帮你完成域名解析的呢因为浏览器本身不具备将消息发送到网络中的功能，所以这一步就是委托操作系统来完成的 操作系统在接收到请求之后，如果是看到是 IP 则直接发送到下一层了；如果是域名，则就把域名发给DNS客户端，然后由 DNS 客户端去连接你网络配置的 DNS 服务器，连接之后请求返回该域名对应的 IP，获取到 IP 之后再交给操作系统，然后继续完成之后的网络请求操作 如果本机配置的 DNS 服务器没有找到该域名对应的 IP 怎么办呢每个联网的终端，都会配置一个 DNS服务器，即便是你没有主动的配置，则每次上网时也会由网关自动分配（这种由网关分配的机制就是 DHCP） 当你在浏览器输入域名之后，OS就会到这个 DNS 服务器上去请求域名对应的IP 地址，如果请求到，则继续完成之前的请求；如果没有请求到，则就会进行分级查询了 域名的层级在了解域名的分级查询之前，先看一下域名的层级，因为就是通过域名的层级进行分级查询的； 下面是百度的域名 1www.baidu.com. 通过域名解析工具，可以看到其实百度官网域名的后面会带一个.,这是因为所有的域名的尾部都会有一个根域名，完整的百度的域名应该是： 1www.baidu.com.root 因为根域名root对所有的域名都一样的，所以平时都会省略点，就变成了https://www.baidu.com. 根域名的下一级域名叫做”顶级域名”（top-level domain，缩写 TLD），比如像.com,.net这些； 再下一级的域名叫做二级域名（second-level domain，缩写 SLD），如：https://www.baidu.com.中的.baidu，这一级的域名是用户可以注册到的； 再下一级的域名就是三级域名也是主机名，如：www，这是用户在自己的域里为服务器配置的名称，是用户可以任意分配的 分级查询所谓的分级查询就是当你在你配置的 DNS 服务器中找不到域名对应的 IP 之后，由当前的 DNS 服务器向根域名服务器发起的请求 首先说明一点，每一级域名都有自己的 NS（Name Server） 记录（记录域名服务器的记录，就是指定那些域名该有哪个 DNS 服务器来解析） 分级查询是从根域名开始，依次查找每一级域名的 NS 记录，找到查到最终的 IP 地址为止，具体查找过程如下： 1231. 从 根域名服务器 找到顶级域名服务器的 NS 记录和 IP 地址2. 从 顶级域名服务器 找到二级域名服务器的 NS 记录和 IP 地址3. 从 二级域名服务器 找到 三级域名（主机名）的 IP 地址 那在分级查询到第一步中是如何知道根域名服务器的地址的呢 这是因为根域名服务器的 NS 记录和 IP 地址一般不会变，所以通常是内置在 DNS 服务器当中的 DNS 缓存如果每次都需要这么解析一遍那么访问一个网站就会变的很慢了，同时也会对根域名服务器造成压力 因此通常就会对 DNS 解析的记录进行缓存，通常有两种缓存的方式： 浏览器缓存浏览器缓存就是每次会对访问过的域名对应的 IP 缓存起来，当然这个缓存的时间也是根据不同的浏览器的厂商而定的；谷歌的一般是缓存一分钟，也可以在谷歌浏览器中输入：chrome://net-internals/#dns来清除缓存 OS缓存 另外一种就是操作系统对于 DNS 的缓存，每次 DNS Client 请求得到的解析记录都会有一个 TTL 值，这个就是 DNS 服务器提供的 DNS 解析结果的最长存活时间，OS 缓存的 DNS 就会参考这个时间，但是不会完全的等于这个时间；通过命令ipconfig/displaydns就可以查看到本机的 DNS 缓存；也可以使用命令ipconfig/flushdns来清除这些缓存 DNS 劫持上面介绍了 DNS 域名解析的原理，现在又有了一个新的问题：什么是 DNS 劫持？ 正常情况下我们在浏览器输入请求后，OS 都会先到本机的 hosts文件查看是否有域名对应的 IP ，如果有则直接通过这个 IP 进行访问就可以了，如果没有，则就会到网络配置的 DNS 服务器上去获取当前域名对应的 IP 地址 但是，如果现在有一个木马程序，入侵你的电脑之后更改了你的 hosts文件，将你访问的百度的域名对应到一个广告网站或者是其他的恶意网站，此时你再访问www.baidu.com的时候出现的就不会是百度的首页了，而是修改之后的恶意网站了，这就是本地 DNS 劫持 本地 DNS 劫持就是因为病毒的入侵，所以你要安装杀毒软件，经常扫描；当然还需要开启防火墙，这样就可以防止病毒的入侵了 除了本地的 DNS 劫持外，还有就是路由器的 DNS 劫持，现在市场上的路由器的质量层级不齐，并且很多的用户买了路由器之后使用的还是默认的密码，所以很容易遭到攻击； 攻击获得管理权限之后，篡改路由器上设置的 DNS 服务器的地址，使其指向恶意的 DNS 服务器，这样当你发送请求的时候就会给你返回恶意网站的 IP地址；所以为了避免这种情况需要加强对路由器账号密码的管理，防止被恶意用户获取到路由器权限 第三种劫持就是攻击权威的 DNS 服务器，导致 DNS 服务器停止服务，还可以使用一些手段感染 DNS 缓存，给用户返回恶意的 IP 地址","categories":[{"name":"网络","slug":"网络","permalink":"https://xinwazi.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://xinwazi.com/tags/DNS/"},{"name":"域名解析","slug":"域名解析","permalink":"https://xinwazi.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"网络","slug":"网络","permalink":"https://xinwazi.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://xinwazi.com/tags/design-pattern/"},{"name":"原型模式","slug":"原型模式","permalink":"https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"DNS","slug":"DNS","permalink":"https://xinwazi.com/tags/DNS/"},{"name":"域名解析","slug":"域名解析","permalink":"https://xinwazi.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]}