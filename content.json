{"meta":{"title":"bad2cat","subtitle":"","description":"Be a thinker!","author":"Adx","url":"https://xinwazi.com","root":"/"},"pages":[{"title":"about","date":"2022-03-02T13:48:10.000Z","updated":"2022-06-17T07:48:55.137Z","comments":true,"path":"about/index.html","permalink":"https://xinwazi.com/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-06-17T07:48:55.137Z","updated":"2022-06-17T07:48:55.137Z","comments":false,"path":"books/index.html","permalink":"https://xinwazi.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-23T13:35:44.000Z","updated":"2022-06-17T07:48:55.137Z","comments":false,"path":"categories/index.html","permalink":"https://xinwazi.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-06-17T07:48:55.137Z","updated":"2022-06-17T07:48:55.137Z","comments":true,"path":"links/index.html","permalink":"https://xinwazi.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-17T07:48:55.137Z","updated":"2022-06-17T07:48:55.137Z","comments":false,"path":"repository/index.html","permalink":"https://xinwazi.com/repository/index.html","excerpt":"","text":""},{"title":"日程表","date":"2022-02-23T13:36:26.000Z","updated":"2022-06-17T07:48:55.137Z","comments":false,"path":"schedule/index.html","permalink":"https://xinwazi.com/schedule/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-23T13:35:54.000Z","updated":"2022-06-17T07:48:55.137Z","comments":false,"path":"tags/index.html","permalink":"https://xinwazi.com/tags/index.html","excerpt":"","text":""},{"title":"test","date":"2022-04-06T09:25:14.000Z","updated":"2022-06-17T07:48:55.137Z","comments":true,"path":"test/index.html","permalink":"https://xinwazi.com/test/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式-代理模式","slug":"设计模式-代理模式","date":"2022-06-17T07:40:52.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"设计模式/设计模式-代理模式-74f5876a802b/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-74f5876a802b/","excerpt":"代理就是替别人完成某个任务，代理模式就是代替客户端去完成客户端需要完成的请求；代理模式和装饰器模式虽然在结构上比较相似，但是它们表达的意义和产生的结果还是有一定的差别的","text":"代理就是替别人完成某个任务，代理模式就是代替客户端去完成客户端需要完成的请求；代理模式和装饰器模式虽然在结构上比较相似，但是它们表达的意义和产生的结果还是有一定的差别的 装饰器模式更像是流水线上的产品，一开始的时候只有一个雏形，经过一些列的装饰器装饰之后就会形成最终需要的产品，也就是说，它最终的结果有可能与一开始的不同 代理模式是帮助客户端去完成客户端不想或者是不能实现的操作，比如：使用http代理翻墙，如果你不使用代理，那么访问像http://www.google.com这样的网站时就会被墙，当你使用http代理时就可以绕过这个墙，将请求发出去，然后获取到响应（虽然 http代理也很容易被墙） 当然，还有一些其他的应用，比如：要实现一个图片下载的服务，如果客户端每次都要从服务器下载，那既浪费时间又会增加服务器的压力，如果能够在客户端有一个代理，在图片第一次下载之后就缓存下来，之后就从这个缓存中获取就会解决这些问题，图片如果不在缓存的话，代理帮你去下载下来返回给客户端，然后添加到缓存中 代理的类图结构 客户端将请求发送到代理，代理收到请求之后检查客户端的权限（如果需要的话），然后将请求发送Service，Service收到请求，返回给代理，再由代理返回给客户端 下面是HTTP代理的一个结构图 用户访问https://www.google.com，浏览器收到用户请求之后，将请求发送到代理服务器（因为代理服务器不在防火墙的黑名单里，所以可以正常接收到请求），代理服务器收到请求之后将请求转发到google服务器（代理服务器在墙外，所以不受限制），google服务器收到请求后，将结果返回给代理服务器，代理服务器再将请求返回给浏览器；这样就能够实现翻墙了 代理模式的Go代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport &quot;fmt&quot;func main() &#123; path1 := &quot;/api/v1/create/user&quot; path2 := &quot;/api/v1/update/user&quot; path3 := &quot;/api/v1/delete/user&quot; app := NewApplication() p := NewProxy(app,2) result1 := p.handleRequest(path1) fmt.Println(result1) result2 := p.handleRequest(path2) fmt.Println(result2) result3 := p.handleRequest(path3) fmt.Println(result3)&#125;type Server interface &#123; handleRequest(string) string&#125;// Application is real servertype Application struct&#123;&#125;func (a *Application) handleRequest(s string) string &#123; if s == &quot;/api/v1/create/user&quot; &#123; return &quot;create success&quot; &#125; if s == &quot;/api/v1/update/user&quot; &#123; return &quot;update success&quot; &#125; return &quot;path not found&quot;&#125;func NewApplication() *Application &#123; return &amp;Application&#123;&#125;&#125;// Proxytype Proxy struct &#123; app *Application allowedRequestTimes int rateLimiter map[string]int&#125;func (p *Proxy) handleRequest(s string) string &#123; allowed := p.checkRequestLimiter(s) if allowed &#123; return p.app.handleRequest(s) &#125; return &quot;over request time&quot;&#125;func (p *Proxy) checkRequestLimiter(url string) bool &#123; if t, ok := p.rateLimiter[url]; ok &#123; if t &gt; p.allowedRequestTimes &#123; return false &#125; p.rateLimiter[url] = t + 1 &#125; else &#123; p.rateLimiter[url] = 1 &#125; return true&#125;func NewProxy(app *Application, t int) *Proxy &#123; return &amp;Proxy&#123; app: app, allowedRequestTimes: t, rateLimiter: make(map[string]int), &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://xinwazi.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-外观模式","slug":"设计模式-外观模式","date":"2022-05-23T01:12:13.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"设计模式/设计模式-外观模式-1fc904650307/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-1fc904650307/","excerpt":"外观模式是一种结构型设计模式，就是为程序、框架和复杂的类提供简单的接口，方便客户端的使用","text":"外观模式是一种结构型设计模式，就是为程序、框架和复杂的类提供简单的接口，方便客户端的使用 解决的问题记得小的时候看的都是那种黑白电视，如果需要更换频道，就要去找到频道模块，然后更换；如果要调整声音大小，那还得跑到电视机前面，找到声音模块调节声音；如果你又觉得电视太暗，你还得跑到电视机跟前，找到明亮度按钮来调整；也就是说，对电视的每个操作都得到电视机上找到对应的模块进行操作，这着实麻烦 后面厂家通过红外技术将电视上这些相关的功能全部封装到了遥控器当中，这样只需要操作遥控器就好了，就不再需要每次都跑到电视机前操作了了 这种应用就是今天要介绍的外观模式，封装多个子系统，只为客户端提供统一的接口，客户端只需要跟这个封装后的对象交互就可以了，不需要关注每个子系统具体的实现细节了 应用外观模式简化了客户端和复杂框架之间的交互，封装了客户端所需的功能，隐藏了实现细节，简化了客户端的使用 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport &quot;fmt&quot;func main() &#123; r := NewRemoter() r.ChangeChannerl() r.AddLight(3) r.ReduceLight(2) r.AddAudio(2) r.RecudeAudio(20)&#125;type Remoter struct &#123; c *VideoChannel a *VideoAudio l *VideoLight&#125;func NewRemoter() *Remoter &#123; return &amp;Remoter&#123; c: &amp;VideoChannel&#123;&#125;, a: &amp;VideoAudio&#123;&#125;, l: &amp;VideoLight&#123;&#125;, &#125;&#125;func (r *Remoter) ChangeChannerl() &#123; r.c.changeChannel()&#125;func (r *Remoter) AddAudio(n int) &#123; r.a.AddAudio(n)&#125;func (r *Remoter) RecudeAudio(n int) &#123; r.a.ReduceAudio(n)&#125;func (r *Remoter) AddLight(n int) &#123; r.l.AddLight(n)&#125;func (r *Remoter) ReduceLight(n int) &#123; r.l.Reduce(n)&#125;type VideoChannel struct&#123;&#125;func (v *VideoChannel) changeChannel() &#123; fmt.Println(&quot;change channel&quot;)&#125;type VideoAudio struct&#123;&#125;func (v *VideoAudio) AddAudio(n int) &#123; fmt.Printf(&quot;add %d audio\\n&quot;, n)&#125;func (v *VideoAudio) ReduceAudio(n int) &#123; fmt.Printf(&quot;reduce audio %d\\n&quot;, n)&#125;type VideoLight struct&#123;&#125;func (v *VideoLight) AddLight(n int) &#123; fmt.Printf(&quot;add light %d\\n&quot;, n)&#125;func (v *VideoLight) Reduce(n int) &#123; fmt.Printf(&quot;reduce light %d\\n&quot;, n)&#125; 优点避免了客户端和子系统之间的紧耦合，增加了代码的灵活性 客户端不需要了解每个子系统的所有功能，只需要调用自己的需要的功能就好了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"外观模式","slug":"外观模式","permalink":"https://xinwazi.com/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://xinwazi.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-组合模式","slug":"设计模式-组合模式","date":"2022-05-09T01:12:13.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"设计模式/设计模式-组合模式-b64439743afc/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-b64439743afc/","excerpt":"组合模式，又称为部分-整体模式，是一种结构型设计模式，可以使用它将相似对象组合成树状结构，并且能像使用独立对象一样使用它们","text":"组合模式，又称为部分-整体模式，是一种结构型设计模式，可以使用它将相似对象组合成树状结构，并且能像使用独立对象一样使用它们 问题模型有两类对象：盒子和商品；一个盒子中有多个商品和更小的盒子，而在这些小的盒子中又有其他的商品和一些更小的盒子，而这些更小的盒子中也有商品和其他更小的盒子，依次类推 现在需要在这些类的基础上开发一个订单系统，在订单中可以包含无包装的商品，也可以包含包装其他商品的盒子，以及其他的盒子；那此时如何计算每张订单的总价呢？ 当然，在现实的生活中，可以一个个的打开所有的盒子，然后将所有盒子中的商品价格加起来就好了 但是，在程序中不能简单的使用循环来完成这种工作；因为，首先你必须知道所有的盒子和商品的类别；其次，你要知道所有的嵌套层数，以及每个盒子的包装细节；这对于程序来说一层层的拆分会变得的非常的复杂，甚至基本不可以 那现在如何才能通过程序解决这个问题呢？答案就是使用组合模式 解决方案组合模式建议通过一个通用的接口与商品和盒子进行交互，并且在这个接口中声明一个计算总价的方法；现在的重点就是放到了如何实现这个计算总价的方法了 对于一个盒子，该方法遍历这个盒子中所有的对象，询问每个对象的价格，然后返回这个盒子的总价；对于一个商品，则直接返回这个商品的价格 如果在这个盒子中还存在其他更小的盒子，遍历这个盒子的所有对象的价格，依次类推，直到计算出所有内部组成部分的价格为止；当然，你也可以在计算每个盒子的价格的时候附加上这个盒子的包装价格作为和盒子的费用 组合模式的最大的优点就是无需了解这个树状结构中对象的具体类型；你也不需要知道对象是商品还是盒子；只需要调用通用的接口中的方法，以相同的方式对其进行处理即可；当你调用该方法后，对象就会沿着这个树结构传递下去 UML类图 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport &quot;fmt&quot;func main() &#123; smallBox := NewGoodsBox() pen := NewPen(10) book := NewBook(12) smallBox.Add(pen) smallBox.Add(book) bigBox := NewGoodsBox() p1 := NewPen(20) p2 := NewPen(10) b1 := NewBook(1) bigBox.Add(p1) bigBox.Add(p2) bigBox.Add(b1) bigBox.Add(smallBox) total := bigBox.Compute() fmt.Println(total)&#125;type Component interface &#123; Compute() int64&#125;type GoodsBox struct &#123; c []Component&#125;func NewGoodsBox() *GoodsBox &#123; return &amp;GoodsBox&#123;&#125;&#125;func (g *GoodsBox) Add(c Component) &#123; if g.c == nil &#123; g.c = make([]Component, 0) &#125; g.c = append(g.c, c)&#125;func (g *GoodsBox) Compute() int64 &#123; var total int64 if g.c == nil &#123; return 0 &#125; for _, c := range g.c &#123; total = total + c.Compute() &#125; return total&#125;type Pen struct &#123; price int64&#125;func NewPen(price int64) *Pen &#123; return &amp;Pen&#123;price: price&#125;&#125;func (p *Pen) Compute() int64 &#123; return p.price&#125;type Book struct &#123; price int64&#125;func NewBook(price int64) *Book &#123; return &amp;Book&#123;price: price&#125;&#125;func (b *Book) Compute() int64 &#123; return b.price&#125; 应用场景组合模式可适用于整体和部分可以统一处理的场景中；比如，学校要统计学生的男女比例，那首先就需要先拿到每个班级的男女生人数，接下来就是统计每个专业的男女人数，每个学院的男女人数，最后获取到整个学校的男女人数，这样就可以获取到整个学校的男女比例了 同样的，不同的对象之间是相互独立的，比如上面的场景中，每个班级也可以计算各个班级的男女比例，每个学院也可以计算各个学院的男女比例，相互之间不会有影响 优点不同类型的对象之间相互独立，一个节点类型的的变化不会影响其他的节点类型 程序的扩展性增强，新增新的节点类型，不会造成对原有结构造成影响 使得客户端对单个对象和组合对象的使用具有一致性","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://xinwazi.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"组合模式","slug":"组合模式","permalink":"https://xinwazi.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-装饰模式","slug":"设计模式-装饰模式","date":"2022-05-09T01:12:13.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"设计模式/设计模式-装饰模式-4159c54d2c06/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-4159c54d2c06/","excerpt":"装饰模式是一种结构型设计模式，是在运行时动态的给现有对象增加一些功能，但同时又不会改变原对象的代码结构 装饰器本质上就是创建一个装饰类，包装了原有类，并且保持装饰类和原有类有相同的方法签名，然后在原有类的方法上增加一些其他的功能 那装饰器主要是用来解决什么问题呢","text":"装饰模式是一种结构型设计模式，是在运行时动态的给现有对象增加一些功能，但同时又不会改变原对象的代码结构 装饰器本质上就是创建一个装饰类，包装了原有类，并且保持装饰类和原有类有相同的方法签名，然后在原有类的方法上增加一些其他的功能 那装饰器主要是用来解决什么问题呢 解决了什么问题通常，当你想要扩展一个类的功能时，首先想到的方法就是使用继承，这样子类不但有了父类的功能，还能对其添加一些新的功能 但使用继承的问题就是，继承产生了一个新的静态类型，无法在运行时修改其行为，只能通过子类来代替父类；并且随着功能的不断增加，会出现各种各样不同的子类，不断增加的子类会导致程序变的越来越复杂 比如：公司有一个异常通知机制（Notifier），一开始的时候只会通过邮件（E-Mail）进行通知 但是，为了能使用户及时响应异常，又增加了短信（Text-Message）通知机制，微信（Wechat）等通知机制；所以，为了满足这种需求就让其他的通知类继承Notifier，然后各个子类再实现自己的通知机制就好了 后来发现，多种不同的通知机制能更加快速的通知到用户，所以现在要在出现异常时用多种通知机制通知用户，比如：同时支持短信和微信，或者同时支持邮件和短信等等 但如果还是使用继承的方式，子类的个数就完全不可控了；这不仅增加了通知代码库的复杂度，同时也会使得客户端代码变的异常的复杂 那现在如何解决这种子类不断膨胀的问题呢？答案就是使用装饰模式 如何解决这个问题封装器是装饰模式的别称，封装器就是在一个对象中封装另一个类的对象，并且与目标对象有相同的方法签名；当接收到客户端的请求的时候，封装器会委派目标对象完成指定的功能，然后再在该方法之前或者之后增加一些自己的代码逻辑，最终有可能改变运行结果 那什么时候封装器可以被称之为真正的装饰器呢？因为封装器与原对象实现了相同的接口，所以对于客户端而言，这些对象是完全一样的 封装器中引用的成员变量可以是遵循相同接口的任意对象，这使得你可以将一个对象放入多个封装器内，并且在该对象上添加这个封装器的组合功能，这就使得封装器变成了一个具有装饰功能的装饰器了 这感觉就像是流水线的工程一样，每到一个节点就会在原有的基础上增加一些新的功能，最终完成整个产品的装配 在消息通知中，我们可以将邮件通知放在基类的通知器当中，而将其他的通知方式放到装饰器当中，并且是他们都是实现相同的接口 在客户端代码中将基础的通知器放入一系列所需要的装饰器当中，形成一个栈结构 因为所有的装饰器都实现了相同的接口，所以客户端只需要和最后一个入栈的对象交互就可以了，并不需要关心是和纯粹的通知器对象交互还是和装饰器对象交互 我们可以使用相同方法来完成其他行为 （例如设置消息格式或者创建接收人列表）。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象 UML 类图 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport &quot;fmt&quot;func main() &#123; e := &amp;ExceptionNotifier&#123;&#125; s := NewWechatNotifer(e) s = NewTextMessageNotifier(s) s.Notify()&#125;type ExceptionNotifier struct &#123;&#125;func (e *ExceptionNotifier) Notify() &#123; fmt.Println(&quot;exception notify&quot;)&#125;type Notifier interface &#123; Notify()&#125;type WechatNotifier struct &#123; notifier Notifier&#125;func NewWechatNotifer(notifier Notifier) Notifier &#123; return &amp;WechatNotifier&#123;notifier:notifier&#125;&#125;func (w *WechatNotifier) Notify() &#123; w.notifier.Notify() fmt.Println(&quot;Notify with wechat&quot;)&#125;type TextMessageNotifier struct &#123; notifier Notifier&#125;func NewTextMessageNotifier(notifier Notifier) Notifier &#123; return &amp;TextMessageNotifier&#123;notifier:notifier&#125;&#125;func (t *TextMessageNotifier) Notify() &#123; t.notifier.Notify() fmt.Println(&quot;Notify with textMsg&quot;)&#125; 应用场景如果不想更改现有的对象，并且希望在运行的时候为现有对象增加新的功能，就可以使用装饰器模式；它可以对原有的对象在运行时增加各种所需要的功能，并且不需要你更改原对象的代码结构 如果你发现使用继承的方式扩展对象的功能会使得代码变的的很复杂，那么就可以使用装饰器模式，通过组合的方式，使得代码更加的灵活 优缺点装饰模式的一些优点： 可以更加灵活的扩展原对象的功能 可以将大功能拆分成各种装饰器，增加代码的灵活性和复用性 装饰模式的一些缺点： 在封装器栈中删除特定的封装器比较困难 各层代码的初始化配置会比较的麻烦 参考链接：https://refactoringguru.cn/design-patterns/decorator","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://xinwazi.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"装饰模式","slug":"装饰模式","permalink":"https://xinwazi.com/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"}]},{"title":"Go依赖管理","slug":"Go依赖管理","date":"2022-05-05T09:56:40.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"Golang-基础知识/Go依赖管理-a6e27b527321/","link":"","permalink":"https://xinwazi.com/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-a6e27b527321/","excerpt":"在 go中有两个非常重要的环境变量： GOROOT： golang的安装路径，Linux 下默认会安装在/usr/local/go之下 GOPATH：存放SDK以外的第三方类库；收藏的可复用的代码，包含三个子目录： – src : 存放项目源码文件 – pkg : 编译后的包文件 – bin ：编译后生成的可执行文件","text":"在 go中有两个非常重要的环境变量： GOROOT： golang的安装路径，Linux 下默认会安装在/usr/local/go之下 GOPATH：存放SDK以外的第三方类库；收藏的可复用的代码，包含三个子目录： – src : 存放项目源码文件 – pkg : 编译后的包文件 – bin ：编译后生成的可执行文件 Go Module从 Go1.11版本开始，引入了Go Module功能，在程序中只有一个go.mod文件，存放依赖列表，而依赖的具体的包默认会下载到GOPATH/pkg/mod目录下面 在运行 go build时，优先引用go.mod文件中的依赖，所以Vendor目录逐渐的被替代了，消失在了大部分的项目当中 go mod的使用在go 1.13以后，go mod就是默认的依赖管理工具，在项目中使用如下的方式创建go.mod文件夹管理依赖 1go mod int 这样整个项目就可以使用go mod来进行管理了 下面是 go mod 的一些常用命令： 12345678go mod download 下载模块到本地缓存，缓存路径是 $GOPATH/pkg/mod/cachego mod edit 是提供了命令版编辑 go.mod 的功能，例如 go mod edit -fmt go.mod 会格式化 go.modgo mod graph 把模块之间的依赖图显示出来go mod init 初始化模块（例如把原本dep管理的依赖关系转换过来）go mod tidy 增加缺失的包，移除没用的包go mod vendor 把依赖拷贝到 vendor/ 目录下go mod verify 确认依赖关系go mod why 解释为什么需要包和模块 go mod中存在的一些问题： 依赖包的地址失效或者下载失败 1此时可以使用 go.mod 文件中的 replace 来替换这个包 之前的项目如何使用go mod管理 1首先把项目移出$GOPATH/src目录，然后运行 go mod init module_name，最后执行 go build 即可 Go VendorVendor 目录是Golang1.5版本引入的，为项目提供了一种离线保存第三方依赖的方法；使用vendor的项目，搜索依赖的顺序如下： 1234当前包下的 vendor 目录向上级目录查找，直到找到 src 下的 vendor 目录在 GOROOT 目录下查找在 GOPATH 下面查找依赖包 项目中使用go vendor安装 1go get -u -v github.com/kardianos/govendor 初始化 12cd xxxgovendor init 初始化完成后，项目目录中会生成一个vendor文件夹，包含一个vendor.json文件，json文件中包含了项目所依赖的所有包信息 123456&#123; &quot;comment&quot;: &quot;&quot;, &quot;ignore&quot;: &quot;test&quot;, &quot;package&quot;: [], &quot;rootPath&quot;: &quot;govendor-test&quot;&#125; govendor常用命令 将已被引用且在 $GOPATH 下的所有包复制到 vendor 目录 1govendor add +external 仅从 $GOPATH 中复制指定包 1govendor add gopkg.in/yaml.v2 列出一个包被哪些包引用 1govendor list -v fmt 从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份) 1govendor fetch golang.org/x/net/context 安装指定版本的包 123govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55govendor fetch golang.org/x/net/context@v1 # Get latest v1.*.* tag or branch.govendor fetch golang.org/x/net/context@=v1 # Get the tag or branch named &quot;v1&quot;. 只格式化项目自身代码(vendor 目录下的不变动) 1govendor fmt +local 拉取所有依赖的包到 vendor 目录(包括 $GOPATH 存在或不存在的包) 1govendor fetch +out 包已在 vendor 目录，但想从 $GOPATH 更新 1govendor update +vendor 各子命令详细用法可通过 govendor COMMAND -h 或阅读 github.com/kardianos/govendor/context 查看源码包如何实现的。 子命令 功能 init 创建 vendor 目录和 vendor.json 文件 list 列出&amp;过滤依赖包及其状态 add 从 $GOPATH 复制包到项目 vendor 目录 update 从 $GOPATH 更新依赖包到项目 vendor 目录 remove 从 vendor 目录移除依赖的包 status 列出所有缺失、过期和修改过的包 fetch 从远程仓库添加或更新包到项目 vendor 目录(不会存储到 $GOPATH) sync 根据 vendor.json 拉取相匹配的包到 vendor 目录 migrate 从其他基于 vendor 实现的包管理工具中一键迁移 get 与 go get 类似，将包下载到 $GOPATH，再将依赖包复制到 vendor 目录 license 列出所有依赖包的 LICENSE shell 可一次性运行多个 govendor 命令 govendor 状态参数 状态 缩写 含义 +local l 本地包，即项目内部编写的包 +external e 外部包，即在 GOPATH 中、却不在项目 vendor 目录 +vendor v 已在 vendor 目录下的包 +std s 标准库里的包 +excluded x 明确被排除的外部包 +unused u 未使用的包，即在 vendor 目录下，但项目中并未引用到 +missing m 被引用了但却找不到的包 +program p 主程序包，即可被编译为执行文件的包 +outside 相当于状态为 +external +missing +all 所有包 支持状态参数的子命令有：list、add、update、remove、fetch govendor的缺点 使用vendor的项目需要把该项目所有的依赖都下载到这个项目中的vendor目录下，这就会导致项目变的很庞大 vendor不区分依赖包的版本，这就意味着可能出现不同的环境依赖了不同版本的包，很有可能导致编译出错 Go mod vendor为了能够在离线的环境中也能够部署和应用程序，就保存了vendor目录；然后，执行如下的命令： 1go mod vendor 就可以将当前程序的依赖拷贝到vendor目录下，当程序中的包使用go mod下载不下来的时候，就可以引用vendor目录下的依赖了","categories":[{"name":"Golang 基础知识","slug":"Golang-基础知识","permalink":"https://xinwazi.com/categories/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Golang 基础","slug":"Golang-基础","permalink":"https://xinwazi.com/tags/Golang-%E5%9F%BA%E7%A1%80/"},{"name":"Go 依赖管理","slug":"Go-依赖管理","permalink":"https://xinwazi.com/tags/Go-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}]},{"title":"设计模式-桥接模式","slug":"设计模式-桥接模式","date":"2022-04-27T02:36:06.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"设计模式/设计模式-桥接模式-b9810bd9d5f8/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-b9810bd9d5f8/","excerpt":"桥接模式是一种结构型设计模式，可以将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用","text":"桥接模式是一种结构型设计模式，可以将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用 问题模型假如现在有一个 Dog类，而你在这个类的基础上扩展出了Poodle Dog和Teddy Dog这两种类型的Dog，之后又希望在添加新的类Size来区分不同大小的 Dog，那么此时你就需要添加新的类SmallPoodleDog,BigPoodleDog,SmallTeddyDog和BigTeddyDog 当然，如果此时有需要一个Color类来区分Dog的颜色，那么这时候就要再进行扩展了，就会出现RedSamllPoodleDog这样的类；这时每增加一种维度的变化就需要增加很多的类，同样每增加一种品种的 Dog，也需要添加很多的类 但是，如果此时直接将这些Small类，Red类组合到PoodleDog中的话，又会增加代码的耦合性，每次Red类的变化都会引起PoodleDog的更改； 那如何才能解决这个问题呢？这就需要用到桥接模式 解决方案桥接模式就是明确识别系统中的独立变化的几个维度，拆分抽象和实现这两个独立的层次结构，降低程序中类的耦合度 也就是说，不能直接让PooleDog组合Red类，中间需要一个桥梁，而这个桥梁就是Red,Blue等同一维度的抽象表示，然后在这个PooleDog中组合这个抽象类，这样就将PooleDog和Red类分离开来了，PooleDog类的变化不会影响Red类，同样的Red的变化也不会影响PooleDog类 这就是设计模式中的依赖倒置原则：要针对接口进行编程，而不是针对实现进行编程；并且能够增加程序的扩展性，降低了程序之间的耦合性 UML类图 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;fmt&quot;func main() &#123; b := &amp;BlueColor&#123;&#125; m := &amp;Medium&#123;&#125; c := &amp;Dog&#123; c: b, s: m, &#125; c.WithMediumBlue()&#125;type Dog struct &#123; c color s Size&#125;func (c *Dog) WithMediumBlue() &#123; c.c.SetColor() c.s.SetSize()&#125;type color interface &#123; SetColor()&#125;type BlueColor struct &#123;&#125;func (b *BlueColor) SetColor() &#123; fmt.Println(&quot;color blue&quot;)&#125;type Size interface &#123; SetSize()&#125;type Medium struct &#123;&#125;func (m *Medium) SetSize() &#123; fmt.Println(&quot;medium size&quot;)&#125; 使用场景当一个类的内部有两种或者多种不同维度的变化时，使用桥接模式可以解耦这些变化的维度，减少程序的耦合性，使代码结构更加的稳定 优点 降低代码的耦合性 减少了不同维度造成的类的数量的增加 可以很好的对程序进行扩展 缺点 增加了代码的复杂度","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"桥接模式","slug":"桥接模式","permalink":"https://xinwazi.com/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-适配器模式","slug":"适配器模式","date":"2022-04-24T03:02:05.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"设计模式/适配器模式-9e46328f333e/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-9e46328f333e/","excerpt":"适配器模式是把一个类的接口变换为另一个类所期望的接口，使得原本因为接口不匹配而无法一起工作的类，变的可以正常调用","text":"适配器模式是把一个类的接口变换为另一个类所期望的接口，使得原本因为接口不匹配而无法一起工作的类，变的可以正常调用 适配器别名有：Wrapper，Adapter，它是一种结构型设计模式，通过扩展原本不适配的类来满足特定的需求 应用场景在计算机当中，有网卡驱动和显卡驱动等等，那这些驱动有什么作用呢？ 作用就是为了能够适配操作系统；计算机发展过程中出现了越来越多的硬件厂商，比如：intel，amd，三星，华为等等，不同的厂商意味着不同的实现细节； 为了能够统一这种不断变化的局面，操作系统为不同的硬件提供了统一了接口，这些接口就是适配器，比如：网卡有网卡适配器，显卡有显卡适配器，而操作系统只是这些适配器通信，而不会管每个硬件具体实现细节； 而响应的各个硬件厂商也只需要为其出厂的对应的硬件实现相应的适配器就好了，实现的这些适配器就是所谓的驱动；这样的话，同一个操作系统就可以对应不同厂商的硬件了，只要该厂商提供了对应的适配器即可 类图和示例代码 示例代码： 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;type Target interface &#123; Print(s string)&#125;type Adapter struct &#123; at *adaptee&#125;func (a *Adapter) Print(msg string) &#123; a.at.PrintMsg(msg)&#125;type adaptee struct &#123;&#125;func (a *adaptee) PrintMsg(msg string) &#123; fmt.Println(msg)&#125;func NewAdapter() *Adapter &#123; return &amp;Adapter&#123;at:&amp;adaptee&#123;&#125;&#125;&#125;func main() &#123; a := NewAdapter() a.Print(&quot;this is adapter pattern&quot;)&#125; 详细代码，可以参考 github 优点 扩展性 在原来的系统中进行了扩展，让其可以适配新的系统，并且不更改原系统的代码 复用性 两个系统接口不符合，但是功能相同，通过适配器只需要进行简单的变化就可以复用了，不需要再将已有的功能再实现一遍 缺点 复杂度 为了适配现有的接口，需要通过增加新的类型进行变换。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://xinwazi.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"Golang-errors","slug":"Golang-errors","date":"2022-04-19T09:32:09.000Z","updated":"2022-06-17T07:48:55.121Z","comments":true,"path":"golang/Golang-errors-8db0fed7c3cd/","link":"","permalink":"https://xinwazi.com/golang/Golang-errors-8db0fed7c3cd/","excerpt":"Golang没有像Java那样的try-catch语句来捕获异常，而是通过error来表达程序中可能出现的错误","text":"Golang没有像Java那样的try-catch语句来捕获异常，而是通过error来表达程序中可能出现的错误 Golang中的error是一个接口类型，所有实现了Error() string方法的类型都可以被认为是error；error的代码如下： 123type error interface &#123; Error() string&#125; 同时，在Golang中有一个内置errors库，里面有一个errorString实现了error接口，代码如下： 123456789101112func New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125;// errorString is a trivial implementation of error.type errorString struct &#123; s string&#125;func (e *errorString) Error() string &#123; return e.s&#125; 同时，errors库还提供了一些函数用来进行错误的处理，接下来一一介绍 errors.Unwrap(err error) error代码如下： 123456789func Unwrap(err error) error &#123; u, ok := err.(interface &#123; Unwrap() error &#125;) if !ok &#123; return nil &#125; return u.Unwrap()&#125; 这个函数的功能就是取出这个error包装的error，也就是说，如果err 中有一个方法为Unwrap() error，那么你调用Unwrap(err)就是给你返回err.Unwrap() 下面是一个具体的例子： 123456789101112131415161718192021type WrapErr struct&#123; msg string err error&#125;func (w *WrapErr) Unwrap() error&#123; return fmt.Errorf(&quot;err:%s&quot;,w.msg)&#125;func main()&#123; err := errors.New(&quot;This is a error&quot;) we := &amp;WrapErr&#123; msg:&quot;This is err&quot;, err:err&#125; if newErr := we.Unwrap();newErr != nil&#123; fmt.Println(newErr.String()) &#125;&#125;//output:err: This is a error errors.Is(err,target error) bool这个方法就是说在err这个错误链中是否有一个error与target相匹配，匹配的话就返回true，否则返回false 那这个错误链是什么呢？就是在这个err上不断的调用Unwrap(err)方法返回的一系列error和这个err本身 那error和target匹配又是什么意思呢？它们的匹配有两种情况： err和target相等，具有同样的值和同样的类型 err中有一个方法Is(error)，并且有err.Is(target)为true 源代码如下： 123456789101112131415161718192021func Is(err, target error) bool &#123; if target == nil &#123; return err == target &#125; // isComparable := reflectlite.TypeOf(target).Comparable() for &#123; if isComparable &amp;&amp; err == target &#123; return true &#125; if x, ok := err.(interface&#123; Is(error) bool &#125;); ok &amp;&amp; x.Is(target) &#123; return true &#125; // TODO: consider supporting target.Is(err). This would allow // user-definable predicates, but also may allow for coping with sloppy // APIs, thereby making it easier to get away with them. if err = Unwrap(err); err == nil &#123; return false &#125; &#125;&#125; errors.As(err,target interface{}) bool这个方法就是在err链中找到与target匹配的error，如果找到，则将这个error赋值给target并且返回true 这个err链就是这个err本身和后续连续调用Unwrap方法得到的error组成 err和target匹配是值，err的值是指针target类型的值，或者是有一个方法As(interfalce)bool使得As(target)返回为 true 源代码如下： 12345678910111213141516171819202122232425func As(err error, target interface&#123;&#125;) bool &#123; if target == nil &#123; panic(&quot;errors: target cannot be nil&quot;) &#125; val := reflectlite.ValueOf(target) / typ := val.Type() // 获取 target 具体类型 if typ.Kind() != reflectlite.Ptr || val.IsNil() &#123; panic(&quot;errors: target must be a non-nil pointer&quot;) &#125; targetType := typ.Elem() if targetType.Kind() != reflectlite.Interface &amp;&amp; !targetType.Implements(errorType) &#123; panic(&quot;errors: *target must be interface or implement error&quot;) &#125; for err != nil &#123; if reflectlite.TypeOf(err).AssignableTo(targetType) &#123; val.Elem().Set(reflectlite.ValueOf(err)) return true &#125; if x, ok := err.(interface&#123; As(interface&#123;&#125;) bool &#125;); ok &amp;&amp; x.As(target) &#123; return true &#125; err = Unwrap(err) &#125; return false&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://xinwazi.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://xinwazi.com/tags/golang/"},{"name":"error","slug":"error","permalink":"https://xinwazi.com/tags/error/"}]},{"title":"设计模式-生成器模式","slug":"设计模式-生成器模式","date":"2022-04-19T01:17:03.000Z","updated":"2022-06-17T07:48:55.125Z","comments":true,"path":"设计模式/设计模式-生成器模式-70c66ed098cd/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-70c66ed098cd/","excerpt":"生成器模式是一种创建型设计模式，使你能够分步骤创建一个复杂对象。该模式还允许你使用相同的创建代码生成不同形式和不同类型的对象，下面通过几个方面具体的说明。","text":"生成器模式是一种创建型设计模式，使你能够分步骤创建一个复杂对象。该模式还允许你使用相同的创建代码生成不同形式和不同类型的对象，下面通过几个方面具体的说明。 解决的问题现在有一个复杂对象，包括很多的成员变量和嵌套对象，如何初始化这个复杂的对象呢？ 通常就是将这些初始化代码放入一个构造方法当中，当然也有可能会放在多个不同的构造方法中 但是，如果将所有的参数都放到一个构造方法中，那么就会有很多冗余的参数；而要是使用多个不同的构造方法的话，不同的参数组合会产生数量不可控的构造方法 不管是使用一个构造方法还是使用多个构造方法，都会在一定程度上增加构造这个对象复杂度，并且会导致这个对象很难扩展，下面使用一个具体的案例来解释一下 比如，现在要构建一个House对象，它包含的基本属性有：door，window，roof，wall，floor，light 等，并且它也可以包含一些其他的设施，如：heating，electricity，gas，yard，pool，soft 等等，那如何构造这个对象呢？如何为不同的人构造不同的House呢？ 最简单的就是在这个House对象的基础上进行扩展，添加pool，soft，heating等等这些对象；最简单的方法就是添加一个超级构造方法将所有的这些属性和嵌套对象都包含进来，但是，这样的话即便构造一个简单House也需要传入很多的构造参数，尽管大部分构造参数根本用不到 当然，还有一种方法就是添加多个构造方法，不同的构造方法构造不同形式的House，但这随着House的属性不断增加，就会导致构造方法的数量不可控了，并且使得代码的扩展性极差 解决方案生成器模式建议将对象构造的代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象当中；将对象的构造划分为一组步骤，如：buildWall()创建墙面，buildDoor创建门等等； 每次创建对象的时候，你可以通过生成器执行一系列步骤；重点就是，你无需调用所有的步骤，只需要调用创建特定对象的那些步骤即可 当然，对于同一类产品可能会有不同的形式，比如：木制的Door和铁制的door；在这种情况下，就可以创建多个不同的生成器，用不同方式实现一组相同的创建步骤，然后在客户端使用这些生成器创建不同形式的对象；比如：WoodHouseBuilder创建木制的房子，IronHouseBuilder则会给你返回一个铁制的房子 主管虽然现在解决了超级构造函数的问题，但是客户端还是得知道构建一个House对象的具体步骤；那有没有一种方法直接生成一个你想要的房子呢？ 答案是有的，就是通过主管类，比如：你现在想要一个木制的房子，那么主管类会将一系列创建木制房子的步骤封装起来，当你使用主管类调用时，主管类就会给你返回给你一个木制的房子，这样就不需要再去了解构建一个木制房子的具体细节了 这样，主管类屏蔽了构建一个木制类房子的细节，真正的做到了客户端和具体的构建对象之间的解耦，更加的利于程序的扩展了 生成器模式结构图和代码 代码示例： 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;type House struct &#123; Wall string Door string Window string Heating string Yard *Yard&#125;type Yard struct &#123; Size int Name string&#125;func newYard(size int, name string) *Yard &#123; return &amp;Yard&#123; Size: size, Name: name, &#125;&#125;func (h *House) String() string &#123; s := fmt.Sprintf(&quot;Door:%s,Wall:%s,Window:%s,Heating:%s&quot;,h.Door,h.Wall,h.Window,h.Heating) if h.Yard != nil&#123; s = fmt.Sprintf(&quot;%s,yard size:%d,yard name:%s&quot;,s,h.Yard.Size,h.Yard.Name) &#125; return s&#125; HouseBuilder 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package maintype HouseBuilder interface &#123; BuildWall() BuildYard() BuildDoor() BuildWindow() BuildHeating() // 如果是同一类型不同形式的对象，则在此处声明获取产品的方法即可 // 如果是不同类型的对象，则需要在具体的 builder 中添加获取该类型产品的方法 GetHouse() *House&#125;// woodBuilder use build wood housetype woodBuilder struct &#123; wall string door string window string heating string yard *Yard&#125;func newWoodBuilder() HouseBuilder &#123; return &amp;woodBuilder&#123;&#125;&#125;func (w *woodBuilder) BuildWall() &#123; w.wall = &quot;white wall&quot;&#125;func (w *woodBuilder) BuildDoor() &#123; w.door = &quot;red wood&quot;&#125;func (w *woodBuilder) BuildYard() &#123; w.yard = newYard(10,&quot;wood yard&quot;)&#125;func (w *woodBuilder) BuildWindow() &#123; w.window = &quot;wood window&quot;&#125;func (w *woodBuilder) BuildHeating() &#123; w.heating = &quot;simonzi&quot;&#125;func (w *woodBuilder) GetHouse() *House &#123; return &amp;House&#123; Wall: w.wall, Door: w.door, Window: w.window, Heating: w.heating, Yard: w.yard, &#125;&#125; Director 12345678910111213141516171819202122package maintype director struct &#123; builder HouseBuilder&#125;func newDirector(builder HouseBuilder) *director &#123; return &amp;director&#123;builder: builder&#125;&#125;func (d *director) SetBuilder(builder HouseBuilder) &#123; d.builder = builder&#125;func (d *director) buildWoodHouse() *House &#123; d.builder.BuildDoor() d.builder.BuildHeating() d.builder.BuildWall() d.builder.BuildWindow() d.builder.BuildYard() return d.builder.GetHouse()&#125; 客户端代码 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; houseBuilder := newWoodBuilder() director := newDirector(houseBuilder) house := director.buildWoodHouse() fmt.Printf(&quot;%s&quot;,house)&#125; 上面创建House对象是通过指定的HouseBuilder创建的，House的参数是默认的；如果你想要动态参数，那么就将这些参数传入到WoodBuild就可以了，因为在这已经确定了这些参数是创建这个所必须的，所以不会出现参数的冗余问题； 对于扩展性而言，对于新增的字段则只需要再新加一个新的生成器就可以了，这样就不需要更改之前的代码就完成了程序的扩展了 注：具体的代码示例可以参考这里","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"生成器模式","slug":"生成器模式","permalink":"https://xinwazi.com/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2022-04-18T01:32:42.000Z","updated":"2022-06-17T07:48:55.121Z","comments":true,"path":"设计模式/设计模式-单例模式-df9309fd2954/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-df9309fd2954/","excerpt":"单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点","text":"单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点 为什么需要控制实例的个数最常见的原因就是为了控制某些共享资源的访问（如：数据库链接，全局的日志等） 单例模式会始终维持只有一个实例，首先会创建一个该对象的全局变量，然后在第一次调用时创建该对象实例赋值给这个全局变量，之后每次新建时都只是返回之前的这个实例，而不是新建一个该对象的实例 实现方式单线程和多线程中实现单例模式的方式有一点不同，这是因为多线程时需要解决同步的问题，所以需要在创建对象时加锁，保证只有一个实例被创建 示例代码： 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;sync&quot;)func main() &#123; s1 := GetSingleton() s2 := GetSingleton() fmt.Println(s1 == s2)&#125;var staticSingleton *Singletonvar lock = &amp;sync.Mutex&#123;&#125;type Singleton struct&#123;&#125;func GetSingleton() *Singleton &#123; if staticSingleton == nil &#123; lock.Lock() defer lock.Unlock() if staticSingleton == nil &#123; staticSingleton = &amp;Singleton&#123;&#125; &#125; &#125; return staticSingleton&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://xinwazi.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Golang 版本更新","slug":"Golang-版本更新","date":"2022-04-15T08:09:54.000Z","updated":"2022-06-17T07:48:55.121Z","comments":true,"path":"Golang/Golang-版本更新-ff6968af57e9/","link":"","permalink":"https://xinwazi.com/Golang/Golang-%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0-ff6968af57e9/","excerpt":"在 Github 下载了一个库，结果这个库要求Go 1.17.x以上的版本，一想还是更新版本吧","text":"在 Github 下载了一个库，结果这个库要求Go 1.17.x以上的版本，一想还是更新版本吧 之前的版本是 1.15.6，现在打算更新到1.17.9； 打开Golang的官网，找到对应的安装包[go1.17.9.linux-amd64.tar.gz](https://golang.google.cn/dl/go1.17.9.linux-amd64.tar.gz) 注： 当时不小心下载成了 arm 的安装包，结果安装之后一直报”二级制格式不正确”，刚开始还很纳闷，结果后来一看，才知道犯了这么低级的错误 下载完安装包之后，执行如下命令： 12cd /usr/localsudo -rf go/ 进入到/usr/local目录下，移除之前的golang版本； 然后将新下载的安装包移动的/usr/local目录下面；接下执行命令解压即可： 1sudo tar -zxvf go1.17.9.linux-amd64.tar.gz 解析之后执行一下go version，看看是否安装成功就可以了 问题：但是这有个问题，就是升级到Go1.17.x之后，在goland中设置Go root时会报一个错误，如下：1the selected directory is not a valid home for go sdk 1.17 查了一下找到了一个解决方案，执行如下命令： 12cd /usr/local/go/src/runtime/internal/sys/sudo vim zversion.go 打开这个golang文件之后，在文件最后面添加如下代码： 1const TheVersion = `go1.17.9` // 这个地方版本就是你安装的版本 然后重新配置GoRoot发现就好了","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xinwazi.com/categories/Golang/"}],"tags":[{"name":"Golang 版本更新","slug":"Golang-版本更新","permalink":"https://xinwazi.com/tags/Golang-%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"},{"name":"Golang 基础","slug":"Golang-基础","permalink":"https://xinwazi.com/tags/Golang-%E5%9F%BA%E7%A1%80/"}]},{"title":"Go初始化过程","slug":"Go初始化过程","date":"2022-04-08T09:44:27.000Z","updated":"2022-06-17T07:48:55.121Z","comments":true,"path":"Golang-基础知识/Go初始化过程-70e8136e1cc3/","link":"","permalink":"https://xinwazi.com/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B-70e8136e1cc3/","excerpt":"在一个Go程序的初始化过程中一般会涉及到如下的一些元素：包，常量，变量，init()，main() 等；程序的初始化一般是从main包开始的；","text":"在一个Go程序的初始化过程中一般会涉及到如下的一些元素：包，常量，变量，init()，main() 等；程序的初始化一般是从main包开始的； 如果main中import了其他的包，那么就会按照import的顺寻优先初始化这些引入的包； 在同一个包下面的.go文件会按照文件名的顺序初始化；在一个.go文件中，初始化的顺序是：常量，变量，init() 函数；如果在这个.go文件下面有多个init()函数，那么就会按照出现的顺序执行 等到引入的包初始化完成之后，就会继续初始化main包了，main包总是最后一个被初始化的；同一个包不管被引入几次，都只会被初始化一次 因为Go不允许循环依赖，所以不会出现A-&gt;B-&gt;C-&gt;A的情况；Go的初始化过程如下图所示：","categories":[{"name":"Golang 基础知识","slug":"Golang-基础知识","permalink":"https://xinwazi.com/categories/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Golang 基础","slug":"Golang-基础","permalink":"https://xinwazi.com/tags/Golang-%E5%9F%BA%E7%A1%80/"},{"name":"Golang 程序初始化顺序","slug":"Golang-程序初始化顺序","permalink":"https://xinwazi.com/tags/Golang-%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"}]},{"title":"hexo按年月分类博客","slug":"hexo按年月分类博客","date":"2022-04-06T08:59:25.000Z","updated":"2022-06-17T07:48:55.121Z","comments":true,"path":"博客搭建/hexo按年月分类博客-f49199d2b5bd/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo%E6%8C%89%E5%B9%B4%E6%9C%88%E5%88%86%E7%B1%BB%E5%8D%9A%E5%AE%A2-f49199d2b5bd/","excerpt":"这两天发现一个问题，就是博客的量慢慢的变多了，但是所有的博客还是在_post这个文件夹下面，感觉乱糟糟的，那有什么办法能进行组织管理呢？","text":"这两天发现一个问题，就是博客的量慢慢的变多了，但是所有的博客还是在_post这个文件夹下面，感觉乱糟糟的，那有什么办法能进行组织管理呢？ 现在找到了两种方式来对_post中的文章进行管理 使用配置new_post_name在hexo的官方文档中找到了一个配置，通过这个配置就可以对文章进行有序的管理； 打开根目录下面的config.yml文件，在文件中有一个配置项为new_post_name，默认值：:title.md，这个:title就是你创建的文章的名称；官方文档中说可以通过更改这个配置来管理你的文章 通过命令hexo new post &quot;title&quot;创建的文章，默认就是在/source/_post目录下面，现在更改这个配置项为： 1new_post_name: :year/:month/:title.md 这样你在通过hexo new post &quot;title&quot;创建文章之后，文章就会在目录/source/_post/2022/04/下面了，这样就可以按照月份对文章进行分类了；当然，你也可以设置new_post_name: :year/:title.md按年进行分类，或者设置为new_post_name: :year/:month:/day/:title.md按天分类 有一个问题：现在我想按照category分类，但是category是创建之后才指定的，那么如何才能在创建的时候指定category，然后按照category分类呢？ 使用命令参数--path第二种方式就是指定文章创建的路径，比如：创建一个test/test.md的文档，命令如下： 1hexo new post --path test/test 这样，生成的文件就会在source/_post/test目录中了，而不是在_post目录下面了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"按年月管理博客","slug":"按年月管理博客","permalink":"https://xinwazi.com/tags/%E6%8C%89%E5%B9%B4%E6%9C%88%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/"}]},{"title":"hexo 博客中的图片不显示的解决方案","slug":"hexo-博客中的图片不显示的解决方案","date":"2022-04-06T06:33:44.000Z","updated":"2022-06-17T07:48:55.129Z","comments":true,"path":"博客搭建/hexo-博客中的图片不显示的解决方案-ee172ebfb43e/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-ee172ebfb43e/","excerpt":"这两天用 hexo搭建了一个个人博客，第一次写完文章之后，发现用MarkDown的方式引用图片之后，图片在博客中不能够正常的显示。","text":"这两天用 hexo搭建了一个个人博客，第一次写完文章之后，发现用MarkDown的方式引用图片之后，图片在博客中不能够正常的显示。 一开始的时候，用的就是如下的这种图片引用的方式来引用图片的： 1![img描述](imgPath) 但是这种方式好像只是在本地起作用，当生成博客系统推送到Github上去之后，图片就显示不了了； 没办法，还得仔细再看看Hexo 官方文档；下面引用文档中的内容： 资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 现在才知道，也就是说如果你有少量的图片那么就直接放到source/images目录下面，然后通过md的图片引用方式就可以了 但是，如果你想按照每个文章来整理对应文章的资源的话，就需要进行一些设置了；打开根目录下面config.yml文件，找到配置项post_asset_folder 设置问true 打开这个功能之后，创建新文章时就会自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们； 当然，当你用了这种方式之后，就不能用md的方式来引用图片了，下面是官方的说明： 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 也就是说，你需要一个插件来解决这个问题；在hexo3中不需要自己安装插件，这个插件已经被加入到了核心代码；你只需要通过一段代码就能够引用图片了： 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 现在举个例子，假如你用hexo new post &quot;FisrtBlog&quot;创建了一篇名为FisrtBlog的文章，同时会在该目录下创建一个名称为FirstBlog的文件夹；当你需要在文章中引入图片时，就可以用如下的代码： 1&#123;% asset_img img.png FisrtBlog] %&#125; img.png就是图片的名称，FisrtBlog是图片的描述；这个图片需要放到FisrtBlog下面，完成之后，再次部署博客到Github之后，打开网站就能够看到引用的图片了 那如何才能试用MarkDone方式呢有时候使用这种方式会感觉很麻烦，假如你想在其他平台也发布这篇文章，那么你还得再改回去；所以还有一种就是通过配置来支持md的方式，再次打开config.yml,然后更改如下的配置： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 设置之后，资源文件夹下面的图片会自动的解析到 post path下面；例如：img.jpg在/2020/01/02/foo/image.jpg，那/2020/01/02/foo/就是post的对应的资源目录，使用![](image.jpg)之后就会自动的将该图片地址渲染为&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;；这样使用 md方式也就能够正确的引用图片了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo 博客","slug":"hexo-博客","permalink":"https://xinwazi.com/tags/hexo-%E5%8D%9A%E5%AE%A2/"},{"name":"博客中图片不显示的问题","slug":"博客中图片不显示的问题","permalink":"https://xinwazi.com/tags/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2022-04-06T05:21:05.000Z","updated":"2022-06-17T07:48:55.133Z","comments":true,"path":"设计模式/设计模式-工厂模式-9291bb2ccc7f/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-9291bb2ccc7f/","excerpt":"工厂模式是一种创建型模式，其在父类提供了一个创建对象的方法，允许子类来决定实例化对象的类型；下面通过一个具体的问题进行说明；","text":"工厂模式是一种创建型模式，其在父类提供了一个创建对象的方法，允许子类来决定实例化对象的类型；下面通过一个具体的问题进行说明； 问题在本地有一个快递公司，使用卡车进行货物的运输; 运输的方式就是实例化Truck类，然后调用 Truck类的Delivery方法就可以完成运输了； 现在公司要扩张业务，需要支持航空运输和轮船运输，那如何能够优雅的应对公司业务的不断的扩张呢？ 要是按照之前的方式，直接添加Ship和Air类的话，就需要更改客户端代码；这样一来，客户端的代码不但变的越来越复杂，并且紧紧的与具体对象的类型耦合在了一起； 如果之后业务不断的增加，会使得客户端代码越来越复杂，而且某一个类的任何一点变化，都需要更改客户端的代码，慢慢的客户端代码就会变的越来越难以维护，就会严重的影响公司的业务的扩张 下面提供了两种方案，来应对快递公司的这种不断变化的业务模型。 简单工厂设计模式首先需要解决的就是客户端代码和对象的类型耦合的问题；我们定义一个Transport接口，在接口类型中声明一个Delivery方法; 然后让不同的运输类实现这个接口，这样对于客户端而言只需要传入具体的运输方式，就可以创建指定的运输对象了，这样客户端代码就不会和对象的具体类型耦合在一起了 代码示例： 1234567891011121314151617181920212223242526272829303132333435import &quot;fmt&quot;type TransportSimple interface &#123; Delivery() string&#125;func CreateTransport(typ string) TransportSimple &#123; switch typ &#123; case &quot;truck&quot;: return &amp;Truck&#123;&#125; case &quot;airPlane&quot;: return &amp;AirPlane&#123;&#125; default: return nil &#125;&#125;type Truck struct&#123;&#125;func (t *Truck) Delivery() string &#123; return fmt.Sprintf(&quot;use truck delivery...&quot;)&#125;type AirPlane struct&#123;&#125;func (a *AirPlane) Delivery() string &#123; return fmt.Sprintf(&quot;use airplane delivery...&quot;)&#125;//客户端代码func main() &#123; t := CreateTransport(&quot;truck&quot;) t.Delivery()&#125; 随着公司运输方式的增加，公司运输的货物也越来越多，但是也收到了不少的差评；因为很多生鲜类的货物，到了用户手里都变质了；还有货物到了快递公司也是随便的堆放； 公司为了解决这些问题，又增加了分类Category和存储Store功能，分类就是在货物到公司后，对货物进行分类；存储的话就是根据分类的结果，对货物分别存储，等到有合适的路线再取出来运输 但是之前的方案好像不能够很好的解决这两种功能的加入，所以公司想有没有一个更加合适的方案，既能应对运输线路的增加，又能解决业务扩张带来的这些问题呢？ 抽象工厂设计模式简单工厂模式只能应对单一产品的变化，一旦产品种类增加之后，简单工厂模式就不能够优雅的应对了；那么此时又有了一个改进的工厂模式：抽象工厂设计模式 在抽象工厂设计模式中，首先需要定义一个AbstractFactory接口，在这个接口中定义创建不同产品的方法；比如： 1234type AbstractFactory interface&#123; CreateProductA() ProductA CreateProductB() ProductB&#125; 然后，定义不同的工厂类型，比如：FactoryA只生产A类型相关的一些列产品，而FactoryB只生产B类型相关的一系列产品 之前的简单工厂模式只能生产出单一功能不同类型的产品，而抽象工厂模式可以生产出多功能，并且各种不同类型的产品； 这就相当于多条生产线，每条生产线生产统一类型相关的一系列产品；客户端只需要创建一个AbstractFactory的实例就可以对货物进行分类，存储，运输等功能了；并且如果之后有其他的功能的话，只需要添加到这个工厂类中就可以了；下面是类图示例： 代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637package maintype Factory interface &#123; CreateTransport() TransportSimple CreateStore() Store&#125;type CreatorA struct&#123;&#125;func (c *CreatorA) CreateTransport() TransportSimple &#123; return &amp;Truck&#123;&#125;&#125;func (c *CreatorA) CreateStore() Store &#123; return &amp;ColdStore&#123;&#125;&#125;type CreatorB struct&#123;&#125;func (c *CreatorB) CreateTransport() TransportSimple &#123; return &amp;AirPlane&#123;&#125;&#125;func (c *CreatorB) CreateStore() Store &#123; return &amp;HotStore&#123;&#125;&#125;func CreateFactory(typ string) Factory &#123; switch typ &#123; case &quot;coldWithTruck&quot;: return &amp;CreatorA&#123;&#125; case &quot;hotWithAirPlane&quot;: return &amp;CreatorB&#123;&#125; &#125; return nil&#125; 这样就能够应对公司业务的不断变化了; 可在 Github 中查看完整代码示例 优缺点优点 你可以避免创建者和具体产品之间的紧密耦合。 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。 缺点 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://xinwazi.com/tags/design-pattern/"},{"name":"原型模式","slug":"原型模式","permalink":"https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-原型模式","slug":"设计模式-原型模式","date":"2022-03-31T10:35:53.000Z","updated":"2022-06-17T07:48:55.133Z","comments":true,"path":"设计模式/设计模式-原型模式-0b54b6ca657c/","link":"","permalink":"https://xinwazi.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-0b54b6ca657c/","excerpt":"原型就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人","text":"原型就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人 原型设计模式原型模式是一种创建型设计模式，它能够帮助你克隆指定的对象，并且无需和对象所属的类耦合，下面通过具体的问题来说明该设计模式的应用场景 问题假如现在有一个对象User，要复制和这个User完全一样的对象要怎么做呢？首先，需要新建一个同类对象，然后将User对象的所有成员变量复制到新对象就好了，但现在有两个问题： 如果有组合类型，那就需要遍历组合类型的成员变量来完成复制；如果变量是私有变量，那么只能再调用获取私有变量的方法才能够实现私有变量的复制； 按照这种方式进行复制的话，这段代码就和对象所属的类产生的紧密的耦合；原对象所属的类发生的任何变化，都要在此处进行相应的更改；如果这种复制代码的操作很多的话，代码就会变的很难维护了 假如User是某个对象所实现的接口类型，就是指在某个方法中参数为接口而传入的具体对象的时候，方法中你拿到的是接口的类型，而不知道对象的具体类型，这种情况下要怎么实现复制呢？ 解决方法上面的问题会在代码中引入对象所属的类，导致两者产生了紧密的耦合；原型设计模式就是将克隆的过程委派给了被克隆的实际对象，这样只需要调用该对象的克隆方法就能够实现复制，而不需要和对象所属的类耦合在一起 首先，原型设计模式为所有支持克隆的对象声明了一个通用的接口，接口中通常只有一个 Clone()的方法；然后，实体类实现该接口，在该方法中完成对象的复制操作；最后客户端调用的时候只需要调用该对象的Clone()方法就能够获取到一个和该对象相同的一个对象 所有的类对Clone()方法的实现都很类似；该方法首先就是创建该类的一个对象，然后将原对象的所有成员变量赋值给新的对象就好了，如果有组合类型，那么调用组合类型的Clone()方法就好了；按照这种方式就可以实现对私有变量的复制了 支持克隆的对象就是原型对象，当你的对象有几十种成员变量和几十种组合类型时，对其进行克隆甚至能够代替子类的构造；比如：创建一系列不同类型的对象用不同的方式进行配置，如果所需对象和预先配置的对象相同，那么就可以使用Clone()方法进行构造 原型设计模式代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type Prototype interface &#123; Clone() Prototype&#125;type Car struct &#123; Name string Color string Age int Kind string which string&#125;func (c *Car) Clone() Prototype &#123; newCar := &amp;Car&#123; Name: c.Name, Color: c.Color, Age: c.Age, Kind: c.Kind, which: c.which, &#125; return newCar&#125;func main() &#123; c := &amp;Car&#123; Name: &quot;BB&quot;, Color: &quot;White&quot;, Age: 1, Kind: &quot;BA&quot;, which: &quot;Me&quot;, &#125; fmt.Println(&amp;c) cc := c.Clone() fmt.Println(reflect.TypeOf(cc)) fmt.Println(cc) fmt.Println(&amp;cc)&#125; 原型注册表原型注册表就是将所有的原型对象存储起来，然后提供一种访问原型对象的方法；比如：可以使用HashMap作为存储，然后将对象的名称作为key，对象实例作为值存储起来；使用的时候通过对象的名称就可以获取到原型对象了 适用场景独立于当前代码假如当前代码中需要复制一些对象，同时又希望代码能够独立于这些对象所属的类，则就可以使用原型设计模式； 原型设计模式提供了一个通用的接口，客户端通过使用这一个通用的接口来完成与克隆对象的交互，使得客户端代码与其克隆对象的类独立开 初始化子类如果子类的区别仅在于其对象的初始化方式，那就可以使用该类来减少子类的数量。因为别人创建这些子类的目的就是为了创建特定类型的对象；在原型模式中，可以使用一系列预生成的，各种类型的对象作为原型；客户端就不需要对子类进行初始化了，只需要找到合适的原型进行克隆就好了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://xinwazi.com/tags/design-pattern/"},{"name":"原型模式","slug":"原型模式","permalink":"https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"搭建个人博客(5) - 集成GithubAction","slug":"集成GithubAction","date":"2022-03-17T10:55:35.000Z","updated":"2022-06-17T07:48:55.137Z","comments":true,"path":"博客搭建/集成GithubAction-e7401dd28c77/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%9B%86%E6%88%90GithubAction-e7401dd28c77/","excerpt":"这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下： 1hexo new post &#x27;Fisrt Blog&#x27;","text":"这样，博客已经搭建好了，可以在本地的根目录下通过命令创建博客，如下： 1hexo new post &#x27;Fisrt Blog&#x27; 执行完命令之后就会在Blog/source/_posts下面生成一个md文档了，然后在该文档中写入想发表的内容之后保存；同样的执行命令： 123hexo cleanhexo ghexo d 然后就可以发布博客到Github了，通过之前购买的域名刷新就可以看到发表的博客了；如果每次都这样写博客会很难受，并且如果更换了电脑，需要重新再打造之前的环境了。那如何解决这个问题呢？ Hexo 持续集成GithubAction为了能够在各个地方都很容易的发表博客，那就需要实现Hexo持续集成；现在有两种集成的方式： 持续集成 Travis CI这种方式可以参考，Hexo 官方文档 持续集成 Github Action说明：Github Action 是Github 的一种执行任务的脚本，将hexo持续集成Gihub Action之后，需要将本地的博客系统push到Github的一个仓库中（也可以是仓库&lt;username&gt;.github.io的一个分支）；之后每次写博客时，只需要将这个博客系统拉到本地，写完之后push上去即可，脚本Github Actions就会自动发布博客的更新 下面就介绍使用Github Action持续集成的例子 添加仓库本文选择将博客系统推送的一个新的分支，所以需要创建一个新的仓库，可以将这个仓库设置为private，因为没必要让别人看到博客的源码，新建的仓库为blog 推送源码，设置 secret在本地的跟目录下面，打开git bash界面，将本地的源码推送到blog仓库； 注：在这里要注意一点，之前下载主题是，在主题那个文件夹会有一个.git隐藏文件，在你推送之前一定要把这个.git文件删除掉，否则推送上去之后主题就会失效 接下来，打开blog仓库的setting，添加secret，如下： 此时需要为Github生成一对公私密钥，参考这里，点击添加之后，key为ACCESS_TOKEN，值就是生成的私钥 设置 Deploy keys 打开仓库&lt;username&gt;.github.io，打开setting，选择Deploy keys添加，key为ACTIONS_DEPLOY_KEY,值就是刚才生成的公钥，如下： 注：如果是在同一个仓库的不同分支则可以使用Github Personal Token，因为这是在不同仓库所以只能使用公私密钥 添加Github Action脚本最后，就是添加GithubAction脚本在blog仓库当中了，打开blog仓库，点击到Action，新建Action脚本 脚本的内容如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041name: Github Pageson: push: branches: - main # main 分支 push 行为时就触发这个 action pull_request:jobs: build-and-deploy: runs-on: ubuntu-latest concurrency: group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; github.ref &#125;&#125; steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2 with: node-version: &#x27;16&#x27; - name: Cache dependencies uses: actions/cache@v2 with: path: ~/.npm key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125; restore-keys: | $&#123;&#123; runner.os &#125;&#125;-node- - run: npm ci - run: npm run build - name: Deploy uses: theme-keep/hexo-deploy-github-pages-action@master env: PERSONAL_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; # The repository the action should deploy to. PUBLISH_REPOSITORY: bad2cat/bad2cat.github.io //这就是push 到博客仓库 # The branch the action should deploy to. BRANCH: main //push 到那个分支 重新部署 现在到本地的博客根目录下，新建一个博客，然后直接将博客源码推送到blog仓库，然后就会触发这个脚本了，这个脚本的作用就是把博客的内容部署到&lt;username&gt;.github.io仓库下面，等一会刷新页面就可以看到部署的结果了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客（4）- 域名解析","slug":"域名解析","date":"2022-03-17T10:35:53.000Z","updated":"2022-06-17T07:48:55.129Z","comments":true,"path":"博客搭建/域名解析-c101a3028bc7/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-c101a3028bc7/","excerpt":"在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的https://&lt;username&gt;.github.io，这个域名收到Github的限制，所以更换一个自定义的域名","text":"在前面的过程中，已经成功的部署了博客，并且更换了博客的主题；接下来，就是更换博客的域名；之前部署完成之后域名是这样的https://&lt;username&gt;.github.io，这个域名收到Github的限制，所以更换一个自定义的域名 域名解析1. 购买域名如果已经有闲置的域名就不需要在购买了；找到阿里云或者腾讯云的官网（在这使用的是阿里云的官网），登入阿里云，找到域名注册 进入之后，输入一个域名，查看是否已经被注册了；（.com的域名有点贵，所以选了一个.com.cn的域名），首年是29，续费是每年39；当然也可以买好几年的 然后加入域名清单，到域名清单进行购买；跳转之后到了如下的下面，选择所有者类型为个人，然后点击创建信息模板，如果之前有则就不用再创建了；现在购买域名都需要实名认证，不过这个认证时间很快，差不多半小时就好了；然后点击购买就好了 2. 域名解析买完域名之后，进入阿里云控制台；然后在你的域名下面添加两条记录 这有两种记录类型： A：表示解析到一个 IP 地址，这个 IP 地址可以通过ping .github.io&#96;获取到 CNAME：表示将购买的这个域名解析到部署博客的那个&lt;username&gt;.github.io这个域名，这是为了防止&lt;username&gt;.github.io 的IP变动 添加 CNAME 文件打开本地博客的根目录，在source目录下面，添加CNAME文件（不带任何后缀），打开该文件将刚才创建的购买的域名写入 执行命令将博客部署到github 123hexo cleanhexo ghexo d 在 Github 配置CNAME 打开github仓库&lt;username&gt;.github.io，可以看到在根目录下有一个CNAME文件； 接下来，在当前项目的Setting中打开Pages页面，然后看域名是否保存，如果没有保存，点击保存即可 这样就可以通过自定义的域名来访问部署的博客了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客(3) - 更换博客主题","slug":"更换博客主题","date":"2022-03-17T10:33:50.000Z","updated":"2022-06-17T07:48:55.129Z","comments":true,"path":"博客搭建/更换博客主题-41b8ba561387/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-41b8ba561387/","excerpt":"现在已经通过 Hexo搭建好了个人博客，并且发布到了Github上，可以通过https://&lt;username&gt;.github.io在公网中访问到了，解析来就是对博客进行一些优化。","text":"现在已经通过 Hexo搭建好了个人博客，并且发布到了Github上，可以通过https://&lt;username&gt;.github.io在公网中访问到了，解析来就是对博客进行一些优化。 更换博客主题Hexo默认的博客主题就是Landscape,如下图所示： 下面是Hexo排名前十的主题，你可以任意挑选一个进行替换 1https://hexo.voxel.site/ 替换主题的步骤 首先到这个主题网站，点击进入到一个你选择的主题网站的Github中，当前选的是next主题，如下所示 下载主题 进入到博客的根目录下面，打开git bash界面，然后输入下面的命令 1git clone https://github.com/theme-next/hexo-theme-next themes/next 更换主题 现在已经将next主题下载到了本地，进入到根目录下的themes目录当中，就可以看到刚才下载的next主题；现在返回到上一层目录，然后打开_config.yml配置文件，在文件中找到theme配置项，更换为next 配置主题 next有四种风格的主题，分别是：Muse，Mist，Pisces，Gemini；对应的样式就是如下的四种： 现在进入到Blog/themes/next目录下面，打开该目录下的_config.yml配置文件，然后找到配置项scheme,然后选择一个填入： 接下来就是保存推出 部署新主题 完成上面的操作后，执行如下的命令，将更改部署到Github上 123hexo cleanhexo ghexo d 此时你在重新在浏览器输入https://&lt;username&gt;.github.io就可以看到新的主题已经更换成功了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客（2）- 部署Hexo到Github pages","slug":"部署Hexo到Github-pages","date":"2022-03-16T07:01:54.000Z","updated":"2022-06-17T07:48:55.133Z","comments":true,"path":"博客搭建/部署Hexo到Github-pages-a3a757356023/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E9%83%A8%E7%BD%B2Hexo%E5%88%B0Github-pages-a3a757356023/","excerpt":"完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 Hexo部署到Github Pages上。","text":"完成上面的操作之后，博客系统就可以在本地进行访问了；但是如果想将博客系统放到公网，可以将 Hexo部署到Github Pages上。 将 Hexo 部署到 GitHub PagesGithubPages 说明GitHub Pages就是一个免费的静态网站托管和发布平台，提供了两种托管的方式： 通过 Github个人或者企业账号托管，这种情况下每个Github账号只能托管一个，并且Repository的名称必须为username.github.io 通过project托管，这样每个project都可以托管一个静态网站，在这种情况下，默认托管在gh-pages分支下面 具体可以参考Github pages官网，当然使用github pages也会有一些限制，比如： 发布的Git Pages站点不超过1GB 每月带宽限制为100GB或100,000次请求 每小时限制构建次数不超过10次 我选择使用Github个人账号托管博客，下面就是详细的将本地Hexo部署到 GitHub Pages的步骤 1. 在 Github创建仓登录到 Github，创建仓库 这个仓库必须创建为public的，仓库的名称就是&lt;username&gt;.github.io，username就是你Github的账号 2. 更改 Hexo 配置现在进入hexo博客的根目录，打开根目录下的配置文件_config.yml 打开之后，滑倒文件底部，找到deploy属性，这一块的内容更改为： 1234deploy: type: git repository: #你的仓库地址 branch: main 更改之后的结果如下所示： 3. 发布到GithubPages完成上面的操作之后，在根目录打开git bash，安装部署插件命令如下： 1npm install hexo-deployer-git --save 安装完成之后，输入一下三条命令进行部署 123hexo clean #清除缓存文件 db.json 和已生成的静态文件 publichexo g #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)hexo d #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写) 完成之后，就可以发现在&lt;username&gt;.github.io仓库中已经有内容了，说明hexo博客已经成功的部署到github上了，接下来在浏览器中输入https://&lt;username&gt;.github.io，就可以看到刚才部署的博客了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"搭建个人博客（1）- 初始化博客","slug":"使用hexo搭建个人blog","date":"2022-03-16T07:01:51.000Z","updated":"2022-06-17T07:48:55.129Z","comments":true,"path":"博客搭建/使用hexo搭建个人blog-2d77129f8c92/","link":"","permalink":"https://xinwazi.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog-2d77129f8c92/","excerpt":"最近想着搭建一个个人博客，然后在网上找到了几种搭建个人博客的方式： 静态网站生成器这种就是在终端使用hexo,hugo,Jekyll等工具，生成一个博客系统，然后通过Github pages进行展示","text":"最近想着搭建一个个人博客，然后在网上找到了几种搭建个人博客的方式： 静态网站生成器这种就是在终端使用hexo,hugo,Jekyll等工具，生成一个博客系统，然后通过Github pages进行展示 优点：可以自己选择博客主题，并且有很多插件实现评论、搜索、流量统计等功能 缺点：没有后台管理系统，需要自己在本地写完之后，发布到github pages上；当然，如果集成github Actions之后，每次写完只需要推送到github就可以了 内容管理系统如：Wordpress，Ghost等，这种更多是企业级的应用，也可以搭建个人博客 这种博客是带有后台管理系统的，但是需要配置数据库、域名和服务器等，这些花费会比较大 第三方平台最简单就是使用第三方平台，如：掘金，简书等；并且会有站点的推广，当然也会受到平台的一些限制 Hexo 搭建个人博客下面主要介绍通过hexo来搭建个人博客，同时添加pure作为该博客系统的主题，主题的样式可以看一下如下的demo hexo-pure 主题 demo 搭建个人博客前提 一个Github的账号，因为现在Github不再支持账密操作了，所以你还需要生成一个Github Personal Token，生成方式： Github不支持账密操作的解决方案 本地安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts 或者下载 安装程序。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装 Node.js node.js 详细安装步骤 安装 Hexo完成上面的操作之后，右键打开Git Bash，输入如下命令安装hexo： 1npm install -g hexo-cli 建站通过上面的命令安装好hexo之后，就可以使用hexo的命令建站了，使用命令 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 执行完成之后，打开新建的目录，可以看到如下的目录列表： 12345678.├── _config.yml //站点配置文件├── package.json // npm 的依赖列表├── scaffolds // 文章模板├── source //这个下面就是具体的文章了| ├── _drafts //草稿箱| └── _posts // 发布的列表└── themes // 当前博客支持的主题，默认只有一个 landscape 此时，已经生成了一个静态的博客系统，可以通过如下的命令来访问本地搭建的博客 hexo g：生成静态文件 hexo d：部署网站 hexo server：在本地启动服务 然后在浏览器中输入http://localhost:4000/就可以访问本地搭建的博客系统了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"DNS 域名解析--详解","slug":"DNS-域名解析","date":"2022-03-13T12:08:56.000Z","updated":"2022-06-17T07:48:55.129Z","comments":true,"path":"网络/DNS-域名解析-836daf7bc346/","link":"","permalink":"https://xinwazi.com/%E7%BD%91%E7%BB%9C/DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-836daf7bc346/","excerpt":"因为网络中数据的传输是通过 TCP/IP协议来完成的，在该协议中传输需要知道对端的 IP地址，然后通过 IP地址完成数据的传输。 那当用户在浏览器中输入域名时，这个域名是如何被转换成 IP地址来完成数据传输的呢？","text":"因为网络中数据的传输是通过 TCP/IP协议来完成的，在该协议中传输需要知道对端的 IP地址，然后通过 IP地址完成数据的传输。 那当用户在浏览器中输入域名时，这个域名是如何被转换成 IP地址来完成数据传输的呢？ 这就是通过域名解析来完成的，域名解析这个词有点抽象，但是换个词可能就比较好理解了，比如：IP登记，域名指向等 就 IP 登记而言，这个词就表明存在这么一个登记处，如果你想你的网站被别人能够访问到，就需要到这个登记处进行登记，在你登记的时候域名就相当于你的名字，IP就相当于你的住址；这样其他用户就可以通过域名来访问你的网站了，不再需要记住那些难记的 IP地址了 上面所说的 IP 登记处就是 DNS 服务器了，每次当你在浏览器输入一个域名时，都会向 DNS 请求这个域名对应的IP地址，找到之后再通过 IP 完成具体的访问操作 是谁帮你完成域名解析的呢因为浏览器本身不具备将消息发送到网络中的功能，所以这一步就是委托操作系统来完成的 操作系统在接收到请求之后，如果是看到是 IP 则直接发送到下一层了；如果是域名，则就把域名发给DNS客户端，然后由 DNS 客户端去连接你网络配置的 DNS 服务器，连接之后请求返回该域名对应的 IP，获取到 IP 之后再交给操作系统，然后继续完成之后的网络请求操作 如果本机配置的 DNS 服务器没有找到该域名对应的 IP 怎么办呢每个联网的终端，都会配置一个 DNS服务器，即便是你没有主动的配置，则每次上网时也会由网关自动分配（这种由网关分配的机制就是 DHCP） 当你在浏览器输入域名之后，OS就会到这个 DNS 服务器上去请求域名对应的IP 地址，如果请求到，则继续完成之前的请求；如果没有请求到，则就会进行分级查询了 域名的层级在了解域名的分级查询之前，先看一下域名的层级，因为就是通过域名的层级进行分级查询的； 下面是百度的域名 1www.baidu.com. 通过域名解析工具，可以看到其实百度官网域名的后面会带一个.,这是因为所有的域名的尾部都会有一个根域名，完整的百度的域名应该是： 1www.baidu.com.root 因为根域名root对所有的域名都一样的，所以平时都会省略点，就变成了https://www.baidu.com. 根域名的下一级域名叫做”顶级域名”（top-level domain，缩写 TLD），比如像.com,.net这些； 再下一级的域名叫做二级域名（second-level domain，缩写 SLD），如：https://www.baidu.com.中的.baidu，这一级的域名是用户可以注册到的； 再下一级的域名就是三级域名也是主机名，如：www，这是用户在自己的域里为服务器配置的名称，是用户可以任意分配的 分级查询所谓的分级查询就是当你在你配置的 DNS 服务器中找不到域名对应的 IP 之后，由当前的 DNS 服务器向根域名服务器发起的请求 首先说明一点，每一级域名都有自己的 NS（Name Server） 记录（记录域名服务器的记录，就是指定那些域名该有哪个 DNS 服务器来解析） 分级查询是从根域名开始，依次查找每一级域名的 NS 记录，找到查到最终的 IP 地址为止，具体查找过程如下： 1231. 从 根域名服务器 找到顶级域名服务器的 NS 记录和 IP 地址2. 从 顶级域名服务器 找到二级域名服务器的 NS 记录和 IP 地址3. 从 二级域名服务器 找到 三级域名（主机名）的 IP 地址 那在分级查询到第一步中是如何知道根域名服务器的地址的呢 这是因为根域名服务器的 NS 记录和 IP 地址一般不会变，所以通常是内置在 DNS 服务器当中的 DNS 缓存如果每次都需要这么解析一遍那么访问一个网站就会变的很慢了，同时也会对根域名服务器造成压力 因此通常就会对 DNS 解析的记录进行缓存，通常有两种缓存的方式： 浏览器缓存浏览器缓存就是每次会对访问过的域名对应的 IP 缓存起来，当然这个缓存的时间也是根据不同的浏览器的厂商而定的；谷歌的一般是缓存一分钟，也可以在谷歌浏览器中输入：chrome://net-internals/#dns来清除缓存 OS缓存 另外一种就是操作系统对于 DNS 的缓存，每次 DNS Client 请求得到的解析记录都会有一个 TTL 值，这个就是 DNS 服务器提供的 DNS 解析结果的最长存活时间，OS 缓存的 DNS 就会参考这个时间，但是不会完全的等于这个时间；通过命令ipconfig/displaydns就可以查看到本机的 DNS 缓存；也可以使用命令ipconfig/flushdns来清除这些缓存 DNS 劫持上面介绍了 DNS 域名解析的原理，现在又有了一个新的问题：什么是 DNS 劫持？ 正常情况下我们在浏览器输入请求后，OS 都会先到本机的 hosts文件查看是否有域名对应的 IP ，如果有则直接通过这个 IP 进行访问就可以了，如果没有，则就会到网络配置的 DNS 服务器上去获取当前域名对应的 IP 地址 但是，如果现在有一个木马程序，入侵你的电脑之后更改了你的 hosts文件，将你访问的百度的域名对应到一个广告网站或者是其他的恶意网站，此时你再访问www.baidu.com的时候出现的就不会是百度的首页了，而是修改之后的恶意网站了，这就是本地 DNS 劫持 本地 DNS 劫持就是因为病毒的入侵，所以你要安装杀毒软件，经常扫描；当然还需要开启防火墙，这样就可以防止病毒的入侵了 除了本地的 DNS 劫持外，还有就是路由器的 DNS 劫持，现在市场上的路由器的质量层级不齐，并且很多的用户买了路由器之后使用的还是默认的密码，所以很容易遭到攻击； 攻击获得管理权限之后，篡改路由器上设置的 DNS 服务器的地址，使其指向恶意的 DNS 服务器，这样当你发送请求的时候就会给你返回恶意网站的 IP地址；所以为了避免这种情况需要加强对路由器账号密码的管理，防止被恶意用户获取到路由器权限 第三种劫持就是攻击权威的 DNS 服务器，导致 DNS 服务器停止服务，还可以使用一些手段感染 DNS 缓存，给用户返回恶意的 IP 地址","categories":[{"name":"网络","slug":"网络","permalink":"https://xinwazi.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://xinwazi.com/tags/DNS/"},{"name":"域名解析","slug":"域名解析","permalink":"https://xinwazi.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Golang 基础知识","slug":"Golang-基础知识","permalink":"https://xinwazi.com/categories/Golang-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"golang","slug":"golang","permalink":"https://xinwazi.com/categories/golang/"},{"name":"Golang","slug":"Golang","permalink":"https://xinwazi.com/categories/Golang/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://xinwazi.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"网络","slug":"网络","permalink":"https://xinwazi.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://xinwazi.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://xinwazi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"外观模式","slug":"外观模式","permalink":"https://xinwazi.com/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://xinwazi.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"组合模式","slug":"组合模式","permalink":"https://xinwazi.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"name":"装饰模式","slug":"装饰模式","permalink":"https://xinwazi.com/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"name":"Golang 基础","slug":"Golang-基础","permalink":"https://xinwazi.com/tags/Golang-%E5%9F%BA%E7%A1%80/"},{"name":"Go 依赖管理","slug":"Go-依赖管理","permalink":"https://xinwazi.com/tags/Go-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"桥接模式","slug":"桥接模式","permalink":"https://xinwazi.com/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://xinwazi.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"golang","slug":"golang","permalink":"https://xinwazi.com/tags/golang/"},{"name":"error","slug":"error","permalink":"https://xinwazi.com/tags/error/"},{"name":"生成器模式","slug":"生成器模式","permalink":"https://xinwazi.com/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://xinwazi.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Golang 版本更新","slug":"Golang-版本更新","permalink":"https://xinwazi.com/tags/Golang-%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"},{"name":"Golang 程序初始化顺序","slug":"Golang-程序初始化顺序","permalink":"https://xinwazi.com/tags/Golang-%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"},{"name":"hexo","slug":"hexo","permalink":"https://xinwazi.com/tags/hexo/"},{"name":"按年月管理博客","slug":"按年月管理博客","permalink":"https://xinwazi.com/tags/%E6%8C%89%E5%B9%B4%E6%9C%88%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/"},{"name":"hexo 博客","slug":"hexo-博客","permalink":"https://xinwazi.com/tags/hexo-%E5%8D%9A%E5%AE%A2/"},{"name":"博客中图片不显示的问题","slug":"博客中图片不显示的问题","permalink":"https://xinwazi.com/tags/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://xinwazi.com/tags/design-pattern/"},{"name":"原型模式","slug":"原型模式","permalink":"https://xinwazi.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"https://xinwazi.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"DNS","slug":"DNS","permalink":"https://xinwazi.com/tags/DNS/"},{"name":"域名解析","slug":"域名解析","permalink":"https://xinwazi.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]}